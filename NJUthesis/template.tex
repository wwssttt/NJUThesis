%% Thesis Template of Nanjing University
%%   for using NJUthesis package with LaTeX2e
%%
%% Created by Wenbo Yang <http://solrex.org>
%% Homepage: http://share.solrex.org/njuthesis/
%%
%% $Id: template.tex,v 0.2 2010/05/01 Exp $


\documentclass[dvipdfm, oneside, master]{NJUthesis}
% 可选参数：
%   nobackinfo 取消封二页导师签名信息
%   oneside/twoside 单面/双面打印
%   phd/master 博士/硕士论文
% 下面三个选一个：
% dvipdfm 使用 dvipdfm(x) 生成最终的 PDF 文档 (缺省设置，不建议修改）
% dvips 使用 dvips 生成最终的 PS 文档
% pdftex 使用 pdfLaTeX 生成最终的 PDF 文档

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 导言区
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 小节标题靠左对齐
\CTEXsetup[format+={\flushleft}]{section}

% 设置链接颜色
\hypersetup{
% pdf 属性
             pdftitle={LaTeX Thesis Template of Nanjing University}, %
            pdfauthor={Wenbo Yang}
}

% 表格
\usepackage{longtable, multirow}
% 英文使用 Times 字体
\usepackage{times}
% 源代码
\usepackage{fancyvrb}
% 自定义列表样式
\usepackage{enumitem}
% 算法
\usepackage{algorithm}
\usepackage{algorithmic}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 封面部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 国家图书馆封面内容字符串
% 仅博士需要填写并保证模板参数选择了 phd
\classification{}
\confidential{}
\UDC{}
\titlelinea{南京大学学位论文}
\titlelineb{~\LaTeX{}~模板}
\titlelinec{}
\advisorinfo{南京大学~数学系}
\chairman{XXX 教授}
\reviewera{某某某某　副研究员}
\reviewerb{XXX 教授}
\reviewerc{XXX 教授}
\reviewerd{XXX 教授}
\nlcfootdate{2010~年~5~月~1~日}

% 南大中文封面内容字符串
\title{一种基于多维时间序列分析的音乐推荐系统研究与实现}
\author{王守涛}
\studentnum{~MF1133033}
\grade{2014}
\advisor{徐锋~~教授}
\major{计算机技术}
\researchfield{可信计算}
\footdate{2014~年~5~月}
\submitdate{2014~年~5~月~10~日}
\defenddate{2014~年~6~月~1~日}

% 英文封面内容字符串
\englishtitle{Research and Implementation of A Music Recommender System Based on Multidimensional Time Series Analysis}
\englishauthor{Shoutao Wang}
\englishadvisor{Professor Xu Feng}
\englishinstitute{Computer Technology}
\englishdegree{Master}
\englishmajor{Computer Technology}
\englishdate{May 2014}

% 制作封面命令
\maketitle

% 制作英文封面命令
\makeenglishtitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 前言部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frontmatter

% 中文摘要
\begin{abstract}

    近些年来，互联网相关技术得到了快速发展，而信息过载~\cite{yang2003visualization}和选择悖论~\cite{scheibehenne2010can} 的问题也愈发显著。为了提升信息的利用率，推荐系统应运而生并已广泛应用在电子商务、音乐电台、个性化阅读等领域。音乐作为一种强力的沟通和自我表达工具已经成为人们日常生活中一种非常重要的消费品,而相关研究也表明人们平时的听歌行为要远远多于读书、看电视、看电影等行为~\cite{rentfrow2003re}。为了解决人们在音乐消费过程中遇到的信息过载和选择悖论问题，一些个性化音乐推荐系统被开发了出来，比如Last.fm~\cite{Lastfm}、Pandora~\cite{Pandora}、豆瓣音乐~\cite{DoubanFM} 等。然而，大多数音乐推荐系统没有充分考虑到用户听歌行为与其所处上下文环境之间的密切关系，导致做出的推荐不符合用户的即时需求，而一些考虑用户上下文的工作对用户行为历史的分析也不够细致和全面。此外，用户的未来行为受到其长期行为、即时行为和中期行为的共同影响，但目前未见工作将这几方面的影响综合起来加以考察。因此，本文给出了一种基于多维时间序列分析的个性化音乐推荐系统以全面细致地对用户行为进行分析。本文的主要贡献和工作如下所示：

    1. 提出了一种基于多维时间序列分析的音乐推荐方法。该方法首先使用主题模型将歌曲表示成由若干隐含主题构成的概率分布，进而将用户行为建模为多维时间序列并对该序列进行分析和预测，从而实现了对用户行为的定量分析。

    2. 从更细的粒度对用户听歌行为进行分析和预测，认为用户的听歌行为在每个隐含主题上都对应着一个时间序列，进而通过对这些时间序列的分析全面考察每一个隐含主题的贡献和作用。

    3. 给出了一种基于用户三期行为的综合音乐推荐方法，综合考虑了用户长期行为、中期行为以及即时行为对用户未来行为的影响和作用。

    4. 实现了一个原型系统，验证了本文所述方法的可行性。其中，本文利用分布式实时计算框架Storm 实现了所述方法的并行化，提升了系统的执行效率。

\keywords{音乐推荐系统; 主题模型; 多维时间序列; 综合推荐}

\end{abstract}

% 英文摘要
\begin{englishabstract}

    In recent years, internet-related technologies have grown rapidly. However, information overload problem and paradox of choice become much more obviously. In order to enhance the utilization of information, recommender systems appear and have been applied to many fields, such as e-commerce, music, and and reading. Being a powerful communication and self-express tool, music has been an important consumer goods in people's daily life and previous research has also indicated that participants listened to music more often than other activities, such as watching television, reading books and watching movies. To alleviating the information overload problem and paradox of choice in music field, some music recommender systems have been developed, such as Lastfm, Douban, Pandora. However, most of recent music recommender systems do not take the close relationship between user's behavior and his/her current context into consideration, leading to bad recommendations that do not match user's current requirement. Although there are some researchers have done some related works, they are not meticulous and comprehensive enough. Besides, user's future behaviors are affected by his/her long-term behaviors, immediately behaviors and middle-term behaviors at the same time and there are few work giving a composite idea on them. In order to get better recommendations, we propose a music recommender system based on multidimensional time series analysis that can analyze the user's behavior more meticulous and comprehensive. Our main contribution and work are as follows:

    1. A method for music recommendation based on multidimensional time series analysis was proposed. The method firstly using topic models to model a song as a probability distribution that is constituted by some latent topics and then it model the user's behavior as a multidimensional time series. By analyzing the time series, the method can forecast the user's future behavior in a quantitative way.

    2. User's behavior was analyzed in finer granularity. With the basic idea of thinking every latent topic corresponds to a time series, we analyze every time series and forecast the future values leading to comprehensive analyzing the influence of all latent topics.

    3. A composite music recommender method was proposed. The method takes into consideration user's long-term behavior, immediate behavior and middle-term behavior at the same time.

    4. A prototype that is used to verify the feasibility of our recommender methods was implemented. Specially, we paralleled the method with an distributed realtime computation framework-Storm, making the system running faster.

\englishkeywords{Music Recommender System, Topic Model, Multidimensional Time Series, Composite Recommendation}

\end{englishabstract}

% 生成目录命令
\tableofcontents

% 以下两个目录可根据具体情况注释掉
% 生成表格目录命令
\listoftables
% 生成插图目录命令
\listoffigures


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter

\chapter{背景介绍}
\label{C:intro}

近些年来，互联网相关技术得到了快速发展，信息呈指数级增长，这造成了严重的信息过载(Information Overload)问题~\cite{yang2003visualization}。特别是随着大数据时代的来临，信息的增长速度已经远远超过人们可以理解的速度，而海量信息中更是包含着很多对人们来说无用的冗余信息以及会干扰人们抉择的错误信息。面对海量的信息和众多的选择，人们往往无所适从而陷入到选择悖论(Paradox of Choice)~\cite{scheibehenne2010can} 之中，或无法做出合理的选择，或需要消耗很大的精力才能做出正确选择。为了解决信息过载问题，减轻人们在做出抉择时所承受的沉重负担，信息分类、搜索引擎和推荐系统等技术应运而生，如表1.1所示。

\begin{table}[!hbp]
\caption{信息过载问题主流解决方案}
\centering
\begin{tabular}{|c|c|c|}
\hline
名称 & 特点 & 案例 \\
\hline
信息分类 & 分门别类地组织信息 & Yahoo!、58同城 \\
\hline
搜索引擎 & 根据关键字进行查询 & Google、百度 \\
\hline
推荐系统 & 分析用户行为历史，主动推荐 & Amazon、淘宝 \\
\hline
\end{tabular}
\end{table}

信息分类技术是通过将互联网上的各种信息分门别类地组织起来来提高人们查询效率的，比如早期的Yahoo! 和国内的58同城等信息分类网站。然而，信息分类技术往往依赖于人工，可扩展性差。随着互联网上信息的增加，这显然不合时宜。搜索引擎技术通过建立索引的方式将互联网上的网页组织起来，然后根据用户输入的关键字进行查询，比如Google 和百度。搜索引擎相对于信息分类技术来说已经有了很大的进步，能够适应互联网的快速发展。然而，人们很多时候要么不愿意费时费力地去输入关键字，要么无法准确地用关键字去描述自己的想法，比如“今天看什么电影好呢？”、“去哪儿吃饭呢？”等，此时搜索引擎就无能为力了。为了解放人们的双手以及深度挖掘人们的内在偏好和需求，推荐系统技术应运而生。

推荐系统本质上是一种信息过滤系统，其通过对用户行为历史的分析挖掘出用户的行为偏好，进而帮助用户将海量信息中的无用信息过滤掉并将符合用户偏好的信息推荐给用户~\cite{adomavicius2005toward}。 目前，推荐系统已经在各个领域得到了广泛的应用，比如电子商务领域的亚马逊和淘宝，在线视频领域的Netflix和优酷，在线音乐领域的Lastfm~\cite{Lastfm} 和豆瓣电台~\cite{DoubanFM}以及个性化阅读领域Flipboard和无觅阅读等。图1.1展示了电子商务领域Amazon的商品推荐系统界面和视频领域PPTV的在线视频推荐系统界面。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/recommender_system.eps}
\caption{Amazon电商推荐及PPTV视频推荐}
\label{fig_recommender_system}
\end{center}
\end{figure}

文献~\cite{rentfrow2003re}表明，人们在日常生活中的听歌行为要远远多于读书、看电影等行为，这说明音乐已经成为人们生活中不可缺少的一部分。音乐推荐系统正是推荐系统在音乐领域的应用，其旨在将人们从海量的音乐中解脱出来，通过分析用户的收听习惯以及歌曲本身的特征来为用户推荐符合用户需求的歌曲~\cite{song2012survey}。与传统的书籍、电影等物品相比，音乐本身以及人们消费音乐的方式具有如下一些特点：

\begin{enumerate}
\item 歌曲往往时间比较短，而且大多是免费的，因此人们消费音乐作品的代价比较低，可以一次性收听一组歌曲。

\item 歌曲本身没有统一的划分标准，流派、心情、场合、年代等都可以作为歌曲的划分标准。比如，按照流派可以将歌曲分为流行、经典、摇滚等类别，按照心情可以分为欢快、伤感、忧伤等类别。

\item 即使是按照一个统一的标准对歌曲进行划分，一首歌曲往往并不是确定地属于某一个类别，而是以不同的程度分属于多个类别。比如，按照流派进行划分，张雨生的经典歌曲“大海”既属于经典也属于流行。

\item 用户在同一个平台下收听歌曲时往往是按照次序一首接着一首收听的，这说明用户对音乐的消费与次序有很强的关联。最后，用户在不同的上下文环境下对音乐作品的喜好也有所不同。比如，用户在睡觉前可能倾向于收听舒缓的歌曲而在运动时倾向于收听快节奏歌曲。
\end{enumerate}

为了满足人们对音乐的个性化需求，一些音乐推荐系统被设计和实现出来，如国外的Lastfm~\cite{Lastfm}、Pandora~\cite{Pandora}以及国内的豆瓣电台~\cite{DoubanFM}、 虾米音乐~\cite{Xiami}，图1.2展示了豆瓣电台和虾米音乐的推荐界面。这些音乐推荐系统首先建立自己的曲库，然后分析歌曲的特征和用户的听歌习惯继而为用户做出推荐。其中，Pandora~\cite{Pandora} 是当今最流行的音乐推荐系统之一，其通过Music Genome Project将400种属性分配给每一首歌曲，进而按照歌曲的相似程度为用户做出推荐。从可见的资料看，Last.fm~\cite{Lastfm}、豆瓣~\cite{DoubanFM} 主要是根据“相似的人往往具有相似的行为”这样的假设为用户做出推荐。虾米音乐~\cite{Xiami} 还给出了推荐的同时还给出了做出推荐的原因，这在一定程度上提升了用户对推荐结果的接收程度。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/douban_xiami.eps}
\caption{豆瓣及虾米音乐电台示意图}
\label{fig_douban_xiami}
\end{center}
\end{figure}

在学术界，学者们也给出了一些有效的音乐推荐算法也被提了出来。按照它们参考用户行为序列长度的长短，我们将这些算法分为全面考察用户所有收听行为的基于用户长期行为的音乐推荐~\cite{resnick1994grouplens}~\cite{chordia2008extending}、仅考察用户当前收听行为的基于用户即时行为的音乐推荐~\cite{downie2003music}~\cite{hyung2012music} 以及考察用户在当前会话期内行为的基于用户中期行为的音乐推荐~\cite{hariri2012context}~\cite{mcfee2011natural}三类。其中，基于用户中期行为的音乐推荐由于考虑了上下文环境对用户行为的影响，因此得到了越来越多的关注。然而，以~\cite{hariri2012context}~\cite{mcfee2011natural} 为代表的基于用户中期行为的音乐推荐算法还存在如下问题：

\begin{enumerate}
\item 只能够定性地分析出目标歌曲可能隶属的类别，但无法定量地给出属于该类别的程度，对用户行为的描述不够细致。

\item 只考虑了若干显著类别的影响，忽视了其他类别对用户行为的贡献和作用，对用户行为的描述不够全面。

\item 在一定程度上依赖于其他用户的行为，但很多时候其他用户的行为很难获取，导致对当前用户行为的预测效果比较差。
\end{enumerate}

为了提高基于中期行为的音乐推荐算法的效果，本文首先给出了一致基于多维时间序列分析的个性化音乐推荐方法，该方法将用户行为建模为一个多维时间序列，从而实现对用户行为细致、全面地分析。

然而，用户的未来行为除了受到用户中期行为的影响之外，还受到用户长期行为和即时行为的作用，但是目前未见工作将这三方面的影响和作用综合起来进行考虑。因此，本文进一步给出了一种基于用户三期行为的综合音乐推荐方法，全面地考察用户长期行为、即时行为和中期行为的贡献和作用。在给出基于多维时间序列分析的音乐推荐方法和基于用户三期行为的综合推荐方法之后，本文通过实验验证了所给方法能够取得比参考方法更高的预测命中率以及更低的推荐误差。最后，本文基于上述方法实现了一个原型系统并且在该系统中实现了本文方法的并行化，验证了所给方法的可行性。

本文结构按照如下方式进行组织：第2章介绍与本文工作相关的一些工作，包括常用的音乐推荐算法、常用的物品相似度计算方法、推荐系统的评测指标以及文本处理、时间序列分析的相关理论等；第3章描述了本文所提的一种基于多维时间序列分析的个性化音乐推荐方法，包括问题的定义、方法的执行流程等；第4章描述了本文在基于多维时间序列分析的音乐推荐方法的基础上进一步给出的基于用户三期行为的综合推荐方法；第5 章给出了本文所实现的原型系统及相关实现技术；第6章对全文进行总结并给出对未来工作的展望。

\chapter{相关工作}
\label{C:relatedwork}

本章我们将介绍与本文工作相关的一些工作，首先我们介绍音乐推荐系统领域常用的一些推荐算法、物品相似度的常用计算方法以及一些常用的算法评估标准，然后我们介绍文本建模、时间序列分析以及实时流处理框架的相关工作，这些方法和技术将在本文后续工作中得到应用。

\section{音乐推荐算法}

目前，音乐推荐系统领域的研究工作已经取得了长足的进步，出现了很多类型的音乐推荐算法。要想为用户推荐合适的歌曲，很多音乐推荐方法都要对用户的听歌行为进行分析。按照算法参照用户行为序列长度的长短，我们将这些音乐推荐算法分为基于用户即时行为的音乐推荐、基于用户长期行为的音乐推荐和基于用户中期行为的音乐推荐三类。本节将对这些推荐算法进行简单的介绍。

\subsection{基于用户及时行为的推荐}

基于用户即时行为的音乐推荐是最为朴素的一种音乐推荐方法，此类音乐推荐算法认为用户的状态在短期内保持稳定，而用户可能收听的下一首歌曲与用户当前收听的歌曲具有类似的特征。假如用户正在收听老狼的《同桌的你》，此类算法首先通过一定的方式抽取歌曲对应的特征即构建歌曲特征向量，并在此基础上将与《同桌的你》具有相似特征的歌曲推荐给用户，比如老狼的另一首经典校园民谣《睡在我上铺的兄弟》，豆瓣电台的“听相似歌曲”实现的正是这样一个功能。因此，以何种方式抽取歌曲特征就成了此类音乐推荐算法工作的关键。音乐作品作为人类情感表达的强有力工具除了具有基本的声学特征之外，还具有流派、心情、场合等特征以及歌曲对应的文本特征，而从不同的角度刻画往往可以得到不同的结果。比如，按照流派划分歌曲可以有流行歌曲、经典歌曲；按照心情划分可以有寂寞、开心、欢快；按照场合划分可以有学习、休息；按照年代划分可以有70后、80后等。文献~\cite{downie2003music}充分利用歌曲的编辑属性，将与当前歌曲具有相同或相似曲作者、歌曲名称以及歌词的歌曲推荐给用户。文献~\cite{bogdanov2011unifying}~\cite{cano2005content}~\cite{mak2010similarity}使用歌曲的声学特征为用户做出推荐，将与当前歌曲具有相似节奏、韵律、音色的歌曲推荐给用户。文献~\cite{kim2010music} 使用心情特征对歌曲进行刻画并将与当前歌曲具有近似心情属性的歌曲推荐给用户。上述工作都是从单一方面对歌曲进行刻画并进而为用户做出推荐，但这种推荐往往是片面的，比如文献~\cite{bogdanov2011unifying}~\cite{cano2005content}对于对声学特征不敏感但对于情感特征敏感的用户就不适用。文献~\cite{hyung2012music}对歌曲对应的文本文档进行分析，使用语义特征对歌曲进行刻画，取得了不错的效果。

基于用户即时行为的音乐推荐是一类比较朴素的推荐算法，其研究核心在于从何角度对歌曲进行刻画和描述并在抽取歌曲特征的基础上为用户推荐相似的歌曲。此类算法尽管也能够取得不错的推荐效果，但其问题也是显而易见的，即对用户行为特征的刻画过于简单，仅仅考察了用户当前行为而忽视了之前的行为。

\subsection{基于用户长期行为的推荐}

与基于用户即时行为的音乐推荐不同的是，基于用户长期行为的音乐推荐对用户所收听的所有歌曲都进行了考察和分析，常见的基于协同过滤的音乐推荐和基于全局特征的推荐都属于此类。

协同过滤推荐(Collabrative Filtering, CF)是当前最为流行的一类推荐算法，其挖掘用户所处的社会化环境，利用群体智能为用户做出推荐。协同过滤推荐基于这样一个假设，即如果两个用户在过去有相同的行为，那么系统认为他们在未来也会有类似的行为~\cite{sarwar2001item}~\cite{linden2003amazon}~\cite{resnick1994grouplens}。当需要预测一个用户是否喜欢一个物品时，协同过滤推荐算法首先找到与当前用户喜好类似的用户，进而综合这些相似用户的喜好为用户推荐新的物品。假如用户A收听了《同桌的你》、《睡在我上铺的兄弟》、《朋友》，用户B 收听了《同桌的你》、《朋友》、《白桦林》，用户C收听了《一无所有》、《北京北京》、《太阳》，那么此类算法认为用户A和用户B 属于相似用户，进而可以将用户B收听但用户A收听的歌曲《白桦林》推荐给A。

基于全局特征的音乐推荐是基于用户长期行为推荐算法中比较朴素的一类推荐方法，此类算法认为用户的长期行为能够反映用户对音乐的偏好。因此，在抽取歌曲特征的基础上，此类算法将用户所收听的所有歌曲的平均特征作为用户的特征并推荐与此平均特征类似的歌曲给用户。文献~\cite{chordia2008extending}使用声学特征对歌曲进行刻画，然后计算用户所收听的所有歌曲的平均特征并以此作为用户特征。

由于基于用户长期行为的音乐推荐对用户的分析比较全面，因此此类算法往往能够得到相较于基于用户即时行为的音乐推荐能够得到比较不错的推荐效果。但是，此类算法对用户所处上下文的考虑不足，无法满足用户的即时需求。

\subsection{基于用户中期行为的推荐}

基于用户中期行为的音乐推荐是这样一类推荐算法，它们认为用户在当前会话期内所收听的歌曲序列能够在一定程度上反映用户所处的上下文环境。因此，它们通过对用户在当前会话期内所收听的歌曲序列进行分析来完成对用户特征的抽取和歌曲的推荐。文献~\cite{park2011session}中给出了“当前会话期”的定义，即指用户正在收听歌曲的这一段连续时间。文献~\cite{park2011session}使用最近收听的几首歌曲去匹配用户的收听历史从而找到类似的收听行为并依据类似行为作出推荐。尽管能够取得一定的效果，但用户所收听的历史不一，对于历史行为少的用户，文献~\cite{park2011session}便无能为力。此外，文献~\cite{park2011session}没有对歌曲空间进行降维，而是直接使用歌曲本身去匹配，这更降低了算法的可行性。文献~\cite{hariri2012context}~\cite{mcfee2011natural}是基于用户中期行为的两类典型代表，这两类算法首先使用文本分析的方法将歌曲表示成由若干隐含主题构成的概率分布并使用若干显著主题表征歌曲。这样，它们便将用户在当前会话期内的收听行为建模为主题序列，通过对该主题序列的分析即可预测目标歌曲可能隶属的主题，进一步地可以讲目标主题中的显著歌曲推荐给用户。其中，文献~\cite{hariri2012context}使用以PrefixSpan为代表的模式挖掘算法对主题序列进行挖掘，而文献是使用~\cite{mcfee2011natural}是使用马尔可夫模型的方法对主题序列进行分析。文献~\cite{hariri2012context}~\cite{mcfee2011natural}能够取得一定地推荐效果，但是他们只是定性地预测目标歌曲可能隶属于哪个隐含主题，无法定量的给出具体的隶属度。此外，它们只是考察若干显著主题的作用和贡献而忽视了其他隐含主题的影响。再者，它们需要依赖其他用户的行为当前用户做出推荐。正是由于存在这些问题，使得文献~\cite{hariri2012context}~\cite{mcfee2011natural}的推荐效果收到很大的限制。

由于基于用户行为的音乐推荐考察了用户所处的上下文环境，因此目前越来越多的工作开始关注此类工作。为了解决文献~\cite{hariri2012context}~\cite{mcfee2011natural}中存在的问题，本文给出一种基于多维时间序列分析的音乐推荐方法，使用主题模型将歌曲表示成一个由若干隐含主题构成的概率分布，并在此基础上将用户在当前会话期的行为表示成一个多维时间序列。通过对该多维时间序列的分析，预测得出用户可能收听的下一首歌曲的特征并从曲库中选择类似的歌曲推荐给用户。

用户的未来行为除了受到用户中期行为的作用之外还受到用户即时行为和长期行为的影响，但目前没有看到比较直观地工作将这三者进行综合考虑。为此，本文在给出一种基于多维时间序列分析的音乐推荐方法的基础上，进一步给出一种基于用户三期行为的综合推荐方法，综合考虑用户三期行为的贡献和作用。

\section{相似度度量}

由前文的介绍可知，几乎所有的音乐推荐方法都会涉及到用户之间相似度的计算或者歌曲之间相似度的计算，而本文工作主要涉及歌曲之间相似度的计算，因此本节将简单介绍几种歌曲相似度的计算方法。

\subsection{余弦相似度}

余弦相似度是推荐系统中计算用户与用户或者物品与物品之间相似度的一种常用方法，其通过测量两个向量内积空间的夹角的余弦值来度量它们之间的相似性。0度角对应的余弦值是1，而其他任何角度对应的余弦值都不大于1，并且其最小值是-1。如果两个向量的指向越接近，那么它们内积空间夹角的余弦值越接近于1，即二者越相似。相反，如果两个向量的指向越相离，那么它们内积空间夹角的余弦值越接近于-1，即二者越不相似。设向量\(\vec {X}_{a}\)和向量\(\vec {X}_{b}\)分别表示用户\emph{a}和用户\emph{b} 的偏好向量，其中\(\vec {X}_{a}(i)\)表示用户\emph{a}对编号为\emph{i}的物品的偏好值或评分，\(\vec {X}_{b}(i)\)表示用户\emph{b}对编号为\emph{i}的物品的偏好值或评分。那么，用户\emph{a}和用户\emph{b}的相似度可以按照公式2.1 进行计算，其中\emph{K}表示物品集合中物品的数目。

\(sim(\emph{a},\emph{b})=cos(\vec {X}_{a},\vec {X}_{b})=\frac{\sum_{i=1}^{K}{\vec {X}_{a}(i)\vec {X}_{b}(i)}}{\sqrt{\sum_{i=1}^{K}{\vec {X}_{b}(i)}^{2}}\sqrt{\sum_{i=1}^{K}{\vec {X}_{a}(i)}^{2}}}\)

\subsection{KL距离}

KL距离也称相对熵或KL散度，是两个概率分布\emph{P}和\emph{Q}差别的非对称性的度量，用来度量使用基于\emph{Q}的编码来编码来自\emph{P} 的样本平均所需的额外的比特个数~\cite{kullback1951information}。如果能够把物品表示称一个概率分布，那么显然可以用KL距离来衡量两个物品之间的相似度。设\(P=({p}_{1},...,{p}_{i},...,{p}_{K})\) 表示物品\emph{p}对应的概率分布，物品\emph{p}对应的概率分布用\(Q=({q}_{1},...,{q}_{i},...,{q}_{K})\)表示，其中\emph{K}表示随机变量的取值数目。那么，物品\emph{p} 和\emph{q}之间的KL距离可以按照公式2.2进行计算，其取值非负。KL散度仅当概率\emph{P} 和\emph{Q} 各自总和均为1，且对于任何\emph{i}皆满足\(\emph{p}_{i}>0\) 及\(\emph{q}_{i}>0\)时才有定义，若式中出现的情况，其值按0处理。

\({dis}_{KL}(p,q)=\sum_{i=1}^{K}ln\frac{{p}_{i}}{{q}_{i}}\)

由于KL距离是非对称的，即

\({dis}_{KL}(p,q)\neq{dis}_{KL}(q,p)\)

而物品之间的相似度应该满足对称性，即

\(sim(p,q)=sim(q,p)\)

因此，不能直接使用KL距离来计算物品之间的相似度，但可以使用\emph{p}到\emph{q}的KL距离与q到p的KL 距离的平均值来作为二者的最终距离，这样就可以满足对称性的要求，如公式2.5 所示。进一步地，可以使用如公式2.6 所示的方法计算二者之间的相似度。

\({dis}_{avgKL}(p,q)=\frac{{{dis}_{KL}(p,q)}+{{dis}_{KL}(q,p)}}{2}\)

\({sim}_{KL}(p,q)=\frac{1}{1+{dis}_{avgKL}(p,q)}\)

\subsection{Hellinger距离}

Hellinger距离也是是一种度量两个概率分布之间相似度的方法。与KL距离不同的是，其天然满足对称性，因此可以直接用来计算物品之间的相似度~\cite{oosterhoff2012note}。 物品p和物品q之间的Hellinger 距离可以按照公式2.7计算，进而按公式2.8可以计算二者之间的相似度。

\({dis}_{hellinger}(p,q)=\frac{1}{\sqrt{2}}\sqrt{\sum_{i=1}^{K}({\sqrt{{p}_{i}}-\sqrt{{q}_{i}}})^{2}}\)

\({sim}_{hellinger}(p,q)=\frac{1}{1+{dis}_{hellinger}(p,q)}\)

本文所提的基于多维时间序列分析的音乐推荐方法及在此基础上给出的基于用户三期行为的综合推荐方法将使用主题模型建模的方法将每一首歌曲表征为由若干隐含主题构成的概率分布。因此，KL 距离和Hellinger 距离将被应用于本文计算两首歌曲之间的相似度的工作中。

\section{评测指标}

推荐系统所研究的问题主要包括评分预测问题、Top-N推荐问题、冷启动问题、可解释性问题以及用户交互问题等~\cite{adomavicius2005toward}。其中，评分预测问题和Top-N推荐问题是得到最广泛研究且最为重要的内容。所谓评分预测问题即根据用户已经产生的评分记录来预测其对尚未评分物品的可能打分，而Top-N推荐是指为用户生成一个包含N个符合其偏好的物品列表。 围绕着这两类问题，研究人员给出了众多推荐算法，本文将简单介绍评测推荐算法优劣的一些指标。

\subsection{用户满意度}

用户作为推荐系统的重要参与者也是推荐系统最终的服务对象，其满意度是评测一个推荐系统优劣的最重要指标。一般来说，用户满意度可以通过对一些用户行为的统计得到。比如，在电子商务网站中可以通过用户的实际购买情况来评判，或者通过设置“满意”/“不满意”按钮进行显示的统计。更一般的情况是，可以使用点击率、用户停留时间和转化率等指标度量用户的满意度。对于本文所研究的音乐推荐系统，可以统计用户在系统上的“喜欢”/“不喜欢”或者“收听”/“放弃”等行为来评估不同算法的推荐效果。显然，用户满意度作为真实场景中的评测指标往往只能通过用户调查或者在线实验的方法获得而无法实现离线计算，这增加了研究人员评估算法优劣的难度。因此，在实际的研究工作中很少通过这个指标来评估不同的推荐算法。

\subsection{预测准确度}

预测准确度是度量一个推荐系统或者推荐算法预测用户行为能力的重要指标。从推荐系统诞生的那一天起，几乎99\%与推荐系统相关的论文都在讨论这个指标，这主要是因为该项指标可以通过离线实验计算，方便了很多学术界的研究人员研究推荐算法。
对于评分预测问题，一般使用均方根误差(Root Mean Square Error, RMSE)和平均绝对误差(Mean Absolute Error, MAE)来表征算法的预测准确度~\cite{herlocker2004evaluating}。RMSE可由公式2.9计算得到。

\(RMSE=\sqrt{\frac{\sum_{u,i\in{T}}{({r}_{ui}-\hat{{r}_{ui}})}^{2}}{|T|}}\)

其中，\emph{T}代表测试集，\emph{u}和\emph{i}表示测试集中的用户和物品，是用户\emph{u}对物品\emph{i}的实际评分，而是推荐算法给出的预测评分。

MAE采用绝对值计算预测误差，如公式2.10 所示。

\(MAE=\frac{\sum_{u,i\in{T}}|{r}_{ui}-\hat{{r}_{ui}}|}{|T|}\)

显然，预测误差越小，那么预测准确度越高，那么推荐算法的效果越好。也就是说，一个优秀的推荐算法在RMSE和MAE这两项指标上的取值往往比较低。

Top-N推荐一般通过准确率(precision)和召回率(recall)来度量算法的优劣。设R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T(u) 是用户在测试集上的行为列表~\cite{powers2011evaluation}。 那么，推荐结果的准确度和召回率如公式2.11和2.12所示.

\(Precision=\frac{\sum_{u\in{U}|R(u)\cap{T(u)}|}}{\sum_{u\in{U}}|R(u)|}\)

\(Recall=\frac{\sum_{u\in{U}|R(u)\cap{T(u)}|}}{\sum_{u\in{U}}|T(u)|}\)

\subsection{其他评测指标}

除了预测准确度这一重要指标之外，推荐系统的评测还有诸如覆盖率、多样性等指标，这些指标从不同的角度看待推荐的有效性。其中，覆盖率(Coverage)描述一个推荐系统对物品长尾的发掘能力，可以简单地定义为推荐系统能够推荐出来的物品占总物品集合的比例。覆盖率越大，说明系统所能推荐的物品越广泛，也说明系统挖掘物品长尾的能力越大。多样性(Diversity)用来描述推荐列表中物品两两之间的不相似性，列表中物品两两之间的相似性越小表示推荐的多样性越大。

考虑到用户满意度无法进行离线实验以及覆盖率、多样性的对推荐算法的表征能力不佳，本文后面主要使用预测准确度来评估本文所提的推荐方法及框架，即评估本文所提推荐方法和框架是否能够得到比其他算法更高的准确度和召回率以及更低的预测误差。

\section{分布式实时计算系统}

尽管目前单机的处理能力已经得到极大的提升，但其在应对大数据时代产生的海量数据时仍然非常吃力。为了解决大数据时代海量数据的处理和分析的问题，Google 提出了一种分布式的计算模型，即MapReduce，该模型使得由一般能力机器组成的集群可以完成大规模或者超大规模的计算工作。在Google工作的启发下，Apache于2005年开发了目前得到广泛应用的分布式应计算框架Hadoop。Hadoop~\cite{Hadoop}对于批处理的工作以及离线的海量数据分析比较有优势，但其对一些在实时性方面要求比较高的计算任务的处理能力有所欠缺。为了弥补Hadoop 的这一缺憾，以Storm~\cite{Storm}为代表的一些分布式实时计算系统被开发了出来，这些系统及框架在实时数据流分析方面能够取得比Hadoop更好的效率和效果。这里，Storm 是由Twitter 开发的一款开源的分布式实时计算框架，其主要适用于流数据处理和分布式远程过程调用两种场景。对于流数据处理场景，Storm可以用来处理源源不断流进来的消息，处理之后将结果写入到某个存储中去。此外，Storm的处理组件是分布式的且处理延迟极低，使得其在分布式远程过程调用的场景中也能够得到比较充分的应用。本文所要解决的问题恰恰是一个实时数据流的分析问题，因此本文后面将会选用Storm 进行数据的分析和处理，本节将对其基本组成及其在分布式远程过程调用中的应用进行介绍。

\subsection{基本组成}

一个传统的Storm集群往往是由一个主控节点(Master Node)和多个工作节点(Work Nodes)组成。其中，主控节点上运行着一个名为“Nimbus” 的守护进程，用于分配代码、布置任务及故障检测，而每个工作节点都运行一个名为“Supervisor”的守护进程，用于监听工作、开始及终止工作进程。Nimbus和Supervisor都能快速失败，而且是无状态的，这样一来它们就变得十分健壮，而两者的协调工作是由Apache ZooKeeper 来完成的。

在Storm中，一个实时应用的计算任务被打包成一个Topology任务发布，且Topology任务一旦提交后永远不会结束，除非用户显式地去停止任务。这里，计算任务Topology是由多个Spout和Bolt计算组件构成，而这些计算组件之间是通过数据流连接起来的。其中，Spout是Storm 中的消息源，用于为Topology 生产消息（数据），一般是从外部数据源（如Message Queue、RDBMS、NoSQL、Realtime Log）不间断地读取数据并发送给Topology；Bolt是Storm 中的消息处理者，用于为Topology进行消息的处理，Bolt可以执行过滤，聚合，查询数据库等操作且可以一级一级的进行处理。Topology中每一个计算组件（Spout和Bolt）都有一个并行执行度，在创建Topology时可以进行指定，Storm会在集群内分配对应并行度个数的线程来同时执行这一组件。图2.5是Twitter Storm官方给出的一个典型的Topology 示意图，其中水龙头表示用以生产数据的Spout组件，闪电表示用户处理数据Bolt组件，消息或数据由Spout组件产生后便在不同的Bolt组件中进行流动并被处理。

除此之外，Storm还有Stream、Stream Grouping、Task、Worker等关键概念。其中，Stream表示被处理的数据；Stream Grouping表示Bolt 接收什么样的数据作为输入数据，即上游组件以何种方式将消息或数据分组并传给下游组件，一般有广播(All Grouping)、随机分组(Shuffle Grouping)、按字段分组(Field Grouping)、直接分组(Direct Grouping)以及不分组(No Grouping)等分组方式；Task表示运行于Spout和Bolt中的线程，而Worker表示运行这些线程的进程。在具体实现时，用户只需要在Spout组件中实现数据读取及分割的逻辑，在Bolt 组件中实现数据的处理逻辑，同时在各组件中指定数据流动的分组方式即可轻松地完成并发布一个实时计算的任务。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/storm.eps}
\caption{典型Twitter Storm示意图}
\label{fig_storm}
\end{center}
\end{figure}

\subsection{分布式过程调用}

分布式远程过程调用（Distributed Remote Procedure Call，DRPC）是联系客户端与Storm集群的一种机制，Storm中引入这一机制的主要目的是利用Storm的实时计算能力来并行化CPU 密集型计算。Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。其中，DRPC通过是DRPC Server 实现的，其整体工作过程如下：

\begin{enumerate}
\item 接收到一个RPC调用请求；

\item 发送请求到Storm上的拓扑；

\item 从Storm上接收计算结果；

\item 将计算结果返回给客户端。
\end{enumerate}
　　　
图2.6更为细致地描述了DRPC的工作流程，大致可以分为如下五个步骤：

\begin{enumerate}
\item Client向DRPC Server发送被调用执行的DRPC函数名称及参数；

\item Storm上的Topology通过DRPCSpout实现这一函数，从DPRC Server接收到函数调用流；

\item DRPC Server会为每次函数调用生成唯一的id；

\item Storm上运行的Topology开始计算结果，最后通过一个ReturnResults的Bolt连接到DRPC Server，发送指定id的计算结果；

\item DRPC Server通过使用之前为每个函数调用生成的id，将结果关联到对应的发起调用的Client，将计算结果返回给Client。
\end{enumerate}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/drpc.eps}
\caption{DRPC工作流程示意图}
\label{fig_drpc}
\end{center}
\end{figure}

\section{文本建模}

为了对歌曲进行全面且完整的描述和刻画，本文将使用文本分析的方法对表征歌曲的文本信息进行分析，本节简单介绍一些基本的文本建模方法。

\subsection{向量空间模型}

计算机不具备人脑的结构，无法理解自然语言，所以需要首先将无结构的自然语言文本转化为计算机可计算的特征文本。为此，Salton等人在20世纪70年代提出了向量空间模型(Vector Space Model, VSM)~\cite{salton1975vector}。向量空间模型首先将每一个文档看做一个词袋(Bag of Words)，即认为一篇文档是由一组词构成的一个集合且词与词之间没有顺序以及先后的关系。其次，向量空间模型将文档表示成一个向量，向量的每一维表示一个词项，而向量每一维的取值表示该词项在文档中的权重。对于文档集合\emph{D}中编号为\emph{j}的文档\({d}_{j}\)，可以将之表示成一个\emph{t}维的向量\(\vec {{d}_{j}}=({\omega}_{1,j},...,{\omega}_{t,j})\)，其中\emph{t}表示词项的数目，\({\omega}_{i,j}(1\leq{i}\leq{t})\) 表示第\emph{i}个词项在文档\({d}_{j}\)中的权重。在对文本进行建模的过程中，词的选取及权重的计算有以下几种典型方式：

\begin{enumerate}
\item 布尔模型。这是最为简单直观的一种计算词项权重的方法，即将词项在文档中是否出现作为其权重，如果词项在文档中出现那么将其权重记为1，否则记为0。虽然这种方法比较简单，但是它没有体现词语在文档中出现的频率。一般来讲，词语在文档中出现的越多，说明它对该篇文档的重要性越大（“的”、“得”、“地”、“是”等停用词除外）。

\item 词频模型。与布尔模型不同的是，词频(Term Frequency, TF)模型统计词项在文当中出现的次数，然后得到词项的频率，并将之作为词项的权重。词项\({t}_{i}\)相对于文档\({d}_{j}\)的词频表示成:

    \({tf}_{i,j}=\frac{{n}_{i,j}}{\sum_{k}{n}_{k,j}}\)

    这里,\({n}_{i,j}\)表示该词项在该文档中出现的次数。这突出了词频对词项重要性的影响，能够取得比布尔模型较好的效果。但是，词语的重要性不仅随着它在文档中出现的次数成正比增加，而且可能会随着它在语料库中出现的频率成反比下降。也就是说，一个词语在整个语料库中出现得越频繁，则它对于文档的重要性越低，对文档的区分度量越差。

\item 词频-逆向文本频率模型。词频-逆向文本频率(Term Frequency - Inverse Document Frequency，TF-IDF)是对上述TF模型的补充，词项的重要性随着其在特定文档中出现次数的增加而增强，但同时随着其在全体文本中出现次数的增加而减弱，即该模型认为对区别文档最有意义的词语应该是那些在文档中出现频率高、而在整个语料库中的其他文档中出现频率少的词语。词项\({t}_{i}\)相对于文档\({d}_{j}\)的TF-IDF取值表示为:

    \({tfidf}_{i,j}={tf}_{i,j}\times{{idf}_{i}}\)

    这里，\({idf}_{i}\)为逆向文本频率，定义为：

    \({idf}_{i}=log\frac{|D|}{|\{j:{t}_{i}\in{{d}_{j}}\}|}\)

    其中，\(|D|\)表示文档集合中的文件总数，\(|\{j:{t}_{i}\in{{d}_{j}}\}|\)表示文档集合中包含词项\({t}_{i}\)的文件数目。TF-IDF 结构简单，容易理解，被广泛应用。但是，其无法准确捕捉文档内部与文档间的统计特征，也不能解决同义词和多义词的问题，因此精确度不是很高
\end{enumerate}

\subsection{隐含狄利克雷模型}

为了解决同义词和多义词的问题，Blei等人于2003年提出了隐含狄利克雷分配模型(Latent Dirichlet Allocation，LDA)~\cite{blei2003latent}~\cite{hoffman2010online}。LDA也是一种典型的词袋模型，其认为一篇文档由多个主题构成，而文档中每一个词都是由对应的主题生成而来。进一步地，LDA被看做是一种主题模型，它将文档看做是一组隐含主题的概率分布。其中，主题表示一个概念、一个方面，表现为一系列相关的单词，是这些单词的条件概率。形象来说，主题就是一个桶，里面装了出现概率较高的单词而这些单词与这个主题有很强的相关性。这样，LDA模型便通过隐含主题将文本与词项联系起来，从而达到降维的目的。LDA是一种生成模型，一篇文档按照如下所示的规则生成：

\begin{enumerate}
\item 假设有两种类型的桶，一种是文档-主题桶，桶里的每一个球代表一个主题；另一种桶是主题-词汇桶，桶中的每一个球代表一个词汇。

\item 文档的生成过程就是不断从桶中取球的过程，每一次先从文档-主题桶中取出球，得到该球代表的主题编号\emph{z}。

\item 从编号为\emph{z}的主题-词汇桶中取球，得到一个词汇。

\item 不断重复2,3两步，即可生成一篇文档。
\end{enumerate}

在LDA模型中，记文档-主题的概率分布为多项式分布\(\vec{\theta}\)，主题-词汇的概率分布为多项式分布\(\vec{\varphi}\)。LDA模型认为\(\vec{\theta}\)和\(\vec{\varphi}\)是模型中的参数，而考虑到和都是多项式分布，模型选择狄利克雷(Dirichlet)分布作为其先验分布。在确定了这些分布之后，LDA下面需要做的就是估计这些分布的参数，如下所示的吉布斯取样（Gibbs Sampling）是目前比较流行的采样方法：

\begin{algorithm}
\caption{LDA模型的Gibbs采样算法}
\label{alg:gibbssampling}
\begin{algorithmic}[1]
\STATE 首先对所有文档中的所有词遍历一遍，为其都随机分配一个主题，即\({z}_{m,n}=k\sim{Mult(1/K)}\) ，其中\emph{m}表示第\emph{m}篇文档，\emph{n}表示文档中的第\emph{n} 个词，\emph{k}表示主题，\emph{K}表示主题的总数，之后将\({{n}^{k}}_{m}\)、\({n}_{m}\)、\({{n}^{t}}_{k}\)、\({n}_{k}\)都加1, 它们分别表示在第\emph{m} 篇文档中主题\emph{k}出现的次数、第\emph{m} 篇文档中主题数量的和、主题\emph{k}对应的词\emph{t} 的次数，\emph{k}主题对应的总词数。

\STATE 对第1篇文档中的所有词进行遍历，假如当前文档中的词\emph{t}对应主题为\emph{k}，则将\({{n}^{k}}_{m}\)、\({n}_{m}\)、\({{n}^{t}}_{k}\)、\({n}_{k}\)都减1, 即先拿出当前词，之后根据LDA中Topic Sample 的概率分布取样出新的主题，再将\({{n}^{k}}_{m}\)、\({n}_{m}\)、\({{n}^{t}}_{k}\)、\({n}_{k}\)都加1。其中，\(\alpha\) 和\(\beta\)为对应的Dirichlet分布的参数，\emph{V}为词汇总数。

\(p({z}_{i}=k|{z}_{-i},w)\propto{\frac{({{n}^{t}}_{k,-i}+{\beta}_{t})({{n}^{k}}_{m,-i}+{\alpha}_{k})}{\sum_{t=1}^{V}({{n}^{t}}_{k,-i}+{\beta}_{t})}}\)

\STATE 重复步骤2直至遍历所有文档。

\STATE 输出LDA模型中的参数\(\vec{\theta}\)和\(\vec{\varphi}\)。

\({\theta}_{m,k}=\frac{{{n}^{k}}_{m}+{\alpha}_{k}}{{n}_{m}+{\alpha}_{k}}\)

\({\varphi}_{k,t}=\frac{{{n}^{t}}_{k}+{\beta}_{t}}{{n}_{k}+{\beta}_{t}}\)

\end{algorithmic}
\end{algorithm}

在本文后续实验中，我们将分别以TF-IDF为代表的向量空间模型和以LDA为代表的主题模型对歌曲对应的文档进行建模，发现LDA能够获得较高的推荐准确率，因此我们将采用LDA作为我们主要的文本建模方法。

\section{时间序列预测}

歌曲时间短、消费代价低的特点决定了其能够较容易的形成序列，且是这种序列有严格的时间顺序，本文工作将通过对用户在会话期内所收听歌曲形成的时间序列的分析来预测用户的接下来的行为。因此，本节将简单介绍一些常用的时间序列预测模型。

\subsection{简单平均法}

简单平均法是以观察期内时间序列的各期数据（观察变量）的平均数作为下期预测值，按照采用的平均方法又可以分为算术平均法、加权平均法和几何平均法三类。其中，算术平均法以观察变量的算术平均数作为下期预测值，加权平均法以观察变量的加权算术平均数作为下期的预测值，而几何平均法是以观察变量的几何平均数作为下期的预测值。简单平均法比较简单、直观，但其预测误差一般偏高。

\subsection{指数平滑法}

指数平滑法是由移动平均法改进而来的，是一种特殊的加权移动平均法。这种方法既有移动平均法的长处，又可以减少历史数据的数量。首先，它把过去的数据全部加以利用。其次，它利用平滑系数加以区分 ，使得近期数据比远期数据对预测值影响更大。它特别适合用于观察值有有长期趋势和季节变动，必须经常预测的情况。按照平滑的次数可以可分为一次指数平滑法和多次指数平滑法。其中，一次平滑法是计算时间序列的一次指数平滑值，以当前观察期的一次指数平滑值为基础，确定下期预测值。与二次移动平均法类似，二次指数平滑法就是对时间序列的一次指数平滑值再次进行指数平滑。

\subsection{差分整合移动平均自回归模型}

差分整合移动平均自回归模型(Autoregressive Integrated Moving Average model,ARIMA)又称为Box-Jenkins方法，是一种由Box和Jenkins于1970年提出的一种时间序列预测方法，目前已经得到广泛的应用~\cite{makridakis1997arma}。在模型ARIMA(p,d,q)中，“AR”表示自回归模型，p 为自回归阶数，“MA” 表示滑动平均模型，q表示滑动平均的阶数，d 表示将时间序列转化为平稳时间序列所作的差分次数，即差分阶数。显然，ARIMA首先需要进行d次差分从而将非平稳序列转化为平稳序列，然后利用自回归模型和滑动平均模型对转换后的平稳序列进行预测。进一步的，模型ARIMA(p,d,q)可以表示成如下三个式子。

\(\Phi(B){(1-B)}^{d}{y}_{t}=\delta+\Theta(B){\varepsilon}_{t}\)

\(\Phi(B)=1-\sum_{i=1}^{p}{\varphi}_{i}{B}^{i}\)

\(\Theta(B)=1+\sum_{i=1}^{q}{\theta}_{i}{B}^{i}\)

其中,为时间序列Y的第t个取值,B是滞后算子，和为模型参数,它们可以通过最小二乘等方法获得。

ARIMA的执行流程主要分为模型识别(Model Identification)、参数估计(Parameter Estimation)和诊断检测(Diagnostic Checking)三个阶段。其中,模型识别阶段主要完成检测序列是否平稳的工作。如果序列不平稳，那么则通过差分的方法将序列转化为平稳序列并给出差分阶数d。在此基础上，识别序列适用的可能模型，如自回归模型或滑动平均模型或者二者的混合。而参数估计阶段主要完成模型参数的估计工作，即通过最小二乘法估计参数和。诊断检测阶段用以检测所给出的模型及参数是否符合条件，如果符合则选用此模型进行预测，否则重新识别模型。

ARIMA模型将应用在本文后续的工作中，已完成对用户行为序列的分析和预测。后续实验结果显示，使用ARIMA模型进行时间序列预测，能够得到较好的效果。

\chapter{一种基于多维时间序列分析的音乐推荐方法}
\label{C:mtsa}

本章将给出一种基于多维时间序列分析的音乐推荐方法，该方法实现了对用户听歌行为定量且全面地分析和预测，同时减少了对其他用户行为的依赖，使得推荐的结果更加符合用户偏好。首先，该方法使用用户给歌曲所打的标签构造歌曲对应的文档，进而通过主题模型的方法对文档集合进行建模并最终把每一首歌曲都表示成由若干隐含主题构成的一个概率分布。在此基础上，该方法将用户在当前会话期内的听歌行为建模为一个多维时间序列，并通过对该多维时间序列分析来预测用户行为，而这样做的原因是该方法认为用户在当前会话期内所收听的歌曲序列能够在一定程度上表征用户所处上下文环境。

我们将在本章中对该方法进行详细的阐述。首先，我们将介绍本文工作所研究问题的相关描述和定义。然后，我们给出该方法的工作流程，包括隐含主题的抽取、多维时间序列的构造及分析预测、最终推荐结果的生成等内容。最后，我们介绍为验证该方法有效性而设计的实验及实验结果。

\section{问题描述}

音乐推荐的目的在于通过对音乐本身属性和用户行为习惯的分析，帮助用户过滤掉不必要的信息，并最终为用户推荐符合其喜好的音乐作品。换句话来说，就是解决如何在已知歌曲特征以及用户之前所收听歌曲的情况下准确地预测用户可能收听的下一首歌曲的问题~\cite{park2011session}，如图3.1所示。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/nextsong.eps}
\caption{下一首歌预测问题的说明图}
\label{fig_nextsong}
\end{center}
\end{figure}

为了更好地描述本文所要研究的问题，我们首先定义用户集和歌曲集，如下所示：

用户集U：所有用户的集合，如下式所示。其中，v表示用户的数目，即\(v=|U|\)。

\(U=\{{u}_{1},{u}_{2},...,{u}_{v}\}\)

歌曲集S：所有可以推荐给用户的物品(这里就是歌曲，本文不加区分地使用“歌曲”和“物品”)的集合，如公式3.2所示。其中，m表示曲库中歌曲的数目，即\(m=|S|\)。为方便起见，我们认为用户收听的歌曲一定在“可推荐歌曲”中。

\(S=\{{s}_{1},{s}_{2},...,{s}_{m}\}\)

对于用户集U中给定的一个用户u，本文所要研究的音乐推荐系统的目标就是为该用户推荐其可能喜欢的下一首歌曲。为了衡量用户对歌曲的喜欢程度，我们定义如下所示的效用函数：

效用函数\(utility(u,s)\): 表征歌曲s对用户u的推荐度(如歌曲s符合用户u喜好的程度、歌曲s与系统所预测歌曲的相似度等)。效用函数反映了用户对某首歌曲的喜爱程度，其值越大表明喜欢程度越大。

如前所述，本文所给的方法是建立在隐含主题分类和用户在一定会话周期内听歌序列的基础上，我们下面进一步地定义歌曲对应的隐含主题集合以及用户所收听歌曲对应的序列。

主题集T: 由所有隐含主题组成的集合，如式公式3.3所示，其中K为隐含主题的数目。

\(T=\{{t}_{1},{t}_{2},...,{t}_{K}\}\)

事件\(e(u,\tau,s)\): 表示用户u在时刻\(\tau\)收听了歌曲s。显然，歌曲s可由用户u和时刻\(\tau\)唯一决定，因此\(e(u,\tau,s)\)可简化为\(e(u,\tau)\)。

序列Q(u): 用户u在给定平台下的所有听歌事件按照时间顺序排列开来得到的序列，公式3.4所示。

\(Q(u)=<e(u,{\tau}_{1}),e(u,{\tau}_{2}),...,e(u,{\tau}_{\pi}),e(u,{\tau}_{\pi+1}),...,e(u,{\tau}_{\pi+n})>\)

其中，\(\pi+n\)为用户u所收听或喜欢的歌曲数目，\(\tau\)为事件发生的时间，且\({\tau}_{1}<{\tau}_{2}<...<{\tau}_{\pi}<{\tau}_{\pi+1}<...<{\tau}_{\pi+n}\)，即用户收听这\(\pi+n\)首歌曲是按照一定的次序一首接一首收听的。另外，Q(u) 中最后n个事件是用户在当前会话期内产生的，即从事件\(e(u,{\tau}_{\pi+1})\)到\(e(u,{\tau}_{\pi+n})\)对应的n首歌曲是用户当前连续收听的，而序列中的最后一个事件是正在发生的。也就是说，这n个听歌事件两两之间没有明显的时间间隔，而事件\(e(u,{\tau}_{\pi+1})\)和事件\(e(u,{\tau}_{\pi})\)之间是由明显的时间间隔的，如下所示。

\(|{\tau}_{\pi+i}-{\tau}_{\pi+i-1}|\le\varepsilon(1<i\le{n})\)

\(|{\tau}_{\pi+1}-{\tau}_{\pi}|>\varepsilon\)

其中\(\varepsilon\)是给定的时间间隔，用以分割不同的听歌会话，在后文的实验中我们将之设为8分钟，而在系统实现中将之设为2小时。为了方便，我们只考察在给定平台下确实有听歌行为的用户，即用户在给定平台下确实有听歌事件且在当前正在该平台下收听歌曲，即当前会话期内的收听事件也是存在。而对于在给定平台下没有任何进行任何听歌行为以及当前不在该平台下听歌的用户，为他们进行推荐比较困难，这是整个推荐系统领域需要重点研究的冷启动问题，本文对此不做深究。

目标歌曲: 符合用户喜好或者用户接下来可能收听的歌曲。

由之前的分析可知，本文所提方法的本质输入是歌曲对应的隐含主题T和用户u当前会话下的收听序列\(Q(u)[\pi+1:\pi+n]\)，而最终目标是为用户推荐其最可能收听的下一首歌曲。也就是说，在已知主题集T 和用户u当前会话期收听序列\(Q(u)[\pi+1:\pi+n]\)的情况下从歌曲集S中找出那些对用户的效用函数取值最大的目标歌曲N(u) 并推荐给用户，如公式3.6 所示。

\(N(u)={\arg\min}_{s\in{S}}u(u,s)\)

为了解决预测用户可能收听的下一首歌曲的问题，有两个难点需要解决：

\begin{enumerate}
\item 如何全面完整地对歌曲进行刻画。

\item 如何对用户的行为序列进行分析以预测用户行为。
\end{enumerate}

\section{方法框架}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/framework.eps}
\caption{基于多维时序分析的音乐推荐方法的工作流程示意图}
\label{fig_framework}
\end{center}
\end{figure}

针对上文所定义的音乐推荐问题，本文提出一种基于多维时间序列分析的音乐推荐方法，该方法按如图3.2 所示的流程工作。其中，虚线箭头表示离线处理模块，主要用来对歌曲进行刻画，即解决难点1；实线箭头表示在线处理模块，主要用来对用户的行为序列进行分析进而预测用户未来的可能行为，即解决难点2。

在离线模块中，我们首先定期从音乐网站上抓取以用户标签为主的歌曲文本信息，然后将这些标签信息按照一定的方式组合成文档，那么这些文档构成的文档集合将和歌曲集S一一对应。关于文档的构造方式，本文采用的方法是将被标记到目标歌曲的标签按照其被标记的次数在目标歌曲对应的文档中重复若干次。假设目标歌曲s 所具有的标签信息可以表示为一个标签集合，比如\(TagSet(s)={<"rock",5>,<"pop",3>,<"male",2>}\)，那么其对应的文档可以表示为Doc(s)=“rock rock rock rock rock pop pop pop male male”。其中，标签“rock” 在Doc(s)中出现5 次，标签“pop” 在Doc(s) 中出现3次,标签“male”在文档Doc(s)中出现2次。由于主题模型是将文档看做一个词袋模型，因此“rock”、“pop”、“male”在文档中出现的顺序不影响建模结果。在获得歌曲集对于的文档集之后，我们对该文档集进行主题模型建模，从而抽取出歌曲中包含的隐含主题。这样，每一首歌曲可以用一个主题权重向量表示，向量中的每一维取值表征该主题对歌曲内容的贡献程度。

在在线处理模块中，我们首先获取用户在当前会话期内所听的歌曲，然后将这些歌曲按照时间先后顺序排开得到用户的当前会话序列。在此基础上并结合离线模块的处理结果，我们将用户的当前会话序列建模为一个多维时间序列。进一步地，我们使用一些经典有效的时间序列预测方法对该多维时间序列的每一个分量进行分析并预测单变量时间序列的下期取值。然后，我们将这些单变量时间序列的预测值组合起来构成目标歌曲的主题向量。得到目标概率分布之后，我们计算曲库中所有歌曲与目标歌曲之间的相似度并按照相似度由大到小排列。最后，我们选取排位靠前的N首歌曲作为推荐列表推荐给用户。在下面的章节中,我们将对方法工作流程中的主要步骤进行一一介绍，包括如何进行主题模型建模、为何选择多维时间序列作为用户行为序列的模型以及相似度计算、最终推荐列表生成等。

\section{主题模型建模}

如前所述，为了更好地刻画歌曲的特征，本文在将歌曲映射成一个个文档的基础上通过主题模型建模来对歌曲进行描述和刻画。隐含狄利克雷分配(Latent Dirichlet Allocation,LDA)模型~\cite{blei2003latent} 是当前最具代表性也是最流行的概率主题模型，已经在文本挖掘、信息处理、多文档摘要等领域得到了广泛的应用~\cite{rosen2004author}~\cite{tang2009multi}，其能够将文档映射到若干隐含主题的分布，而这个分布可以用一个主题权重向量表示，向量的每一维表征了该维主题对文档内容的贡献程度。通过LDA 主题模型建模，我们不但可以抽象出文档包含的隐含主题集合T，而且能够以量化的方式表达不同文档之间的距离和相似度。本节详细介绍利用LDA 主题模型对歌曲建模的过程。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/squares.eps}
\caption{Last.fm中歌曲Squares的标签云}
\label{fig_squares}
\end{center}
\end{figure}

首先，我们从Lastfm(http://last.fm)、豆瓣(www.douban.com)等音乐网站上抓取用户对歌曲所标注的标签,这些标签对歌曲内容的描述比较全面，既包含了歌曲的名称、曲作者信息、专辑信息、发行年代等基本信息，还包含了歌曲所表达主题、歌曲类型、用户心情、适合场合等扩展信息。以The Beta Band 的Squares 为例，用户为其标注的标签有表征年代的“2002”/“2000s”、表征类型的“indie rock”/“folk pop”、表征用户感受的“beautiful”/“want” 等，如图3所示。在得到歌曲对应的标签信息后，我们将这些标签按照一定的方式进行组织，从而生成歌曲对应的文本文档。为了减少噪音，我们只利用那些被多数人使用的标签来完成歌曲对应文档的构造，具体来说我们只考虑被标记次数大于10的标签。这样，每一首歌曲s都将对应一篇文档d，而歌曲集S将对应到一个文档集D。最后，我们对文档集D进行LDA主题模型建模，从而得到包含K个用来全面刻画歌曲特征的隐含主题集合T。同时，对于歌曲集S 中的任意歌曲s，我们能够得到其对应的隐含主题权重的向量，如式公式3.7所示。

\(\vec{s}=({\omega}_{1},{\omega}_{2},...,{\omega}_{i},...,{\omega}_{K})(1\le{i}\le{K})\)

其中，当\({\omega}_{i}=0\)时表示歌曲完全不属于该隐含主题代表的类别，即该隐含主题对歌曲的内容完全没有贡献；当\({\omega}_{i}=1\)时表示歌曲完全属于该隐含主题代表的类别；当\(0<{\omega}_{i}<1\) 时表示歌曲在一定程度上隶属于该隐含主题代表的类别。

表3.1展现了歌曲Squares的若干显著主题及其隶属于这些主题的概率。由表1可以看出，歌曲Squares隶属于主题508的概率为0.215，这说明主题508对该歌曲贡献度为0.215。类似的，主题231对歌曲的贡献度为0.072，这说明主题75对该歌曲的贡献度为0.072。因此，我们认为歌曲能够以更大的概率划分到主题508 中。如前所述,我们不去也无法描述这些主题具体是什么含义，而我们正是利用这一点来回避确定性分类带来的弊端。

\begin{table}[!hbp]
\caption{歌曲Squares的显著主题及隶属度}
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
主题id & 508 & 313 & 296 & 106 & 231 \\
\hline
隶属度 & 0.215 & 0.186 & 0.134 & 0.084 & 0.072 \\
\hline
\end{tabular}
\end{table}

更形象地，我们可以使用雷达图来表示歌曲在各个隐含主题上的隶属程度。假设隐含主题的数目为4且编号依次为\#1、\#2、\#3、\#4，那么主题向量\(\vec{s}=(0.15,0.25,0.15,0.45)\) 代表的歌曲的雷达图如下图所示。其中，雷达图的每个顶点代表一个隐含主题，中心点到各个顶点的距离表示歌曲在该顶点对应隐含主题的隶属度。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.4\textwidth]{figures/singleradar.eps}
\caption{歌曲的雷达图表示}
\label{fig_singleradar}
\end{center}
\end{figure}

\section{多维时间序列构造与预测}

传统的基于“最相似”假设的推荐方法只考虑用户当前的收听习惯，较少考虑用户行为所形成的序列性趋势，而本文所提出的基于多维时间序列分析的音乐推荐方法则对此进行了考虑。在通过LDA主题模型对歌曲进行建模而得到歌曲对应的主题权重向量后，我们需要做的就是获取用户对应的在一定会话周期内收听的歌曲构成的序列并构造其对应的时间序列，然后使用相应的时间序列分析方法进行预测。

对于上文中给出的一共收听了n首歌曲且在当前会话期内收听了\(\pi+n\)首歌曲的用户u来说，为了预测其可能收听的下一首歌曲，我们需要获取该歌曲对应的主题权重向量，如式3.8 所示。

\({\vec{s}}_{\pi+n+1}=({\omega}_{1}(\pi+n+1),{\omega}_{2}(\pi+n+1),...,{\omega}_{i}(\pi+n+1),...,{\omega}_{K}(\pi+n+1))\)

其中，\({\omega}_{i}(j)\)表示第j首歌曲隶属于第i个隐含主题的概率\((1\le{i}\le{K})\)。直接得到这样一个主题向量往往是不太容易的，但估计出该向量对应的每一维的取值往往是可行的。因此，要得到下一首歌曲对于的主题向量，我们需要先估计出对应的主题权重向量中每一维的值，然后将这些中间估计值组合起来即可构成完整地估计主题向量，从而能够在歌曲集S中找到最匹配的歌曲推荐给用户。

由前文可知，用户u的听歌行为是有时间顺序的。如果我们将用户在某一时间点收听的歌曲对应的主题向量看做变量，那么将此变量在不同时间点的取值按照时间顺序依次排开即可得到如下所示的多维时间序列~\cite{hamilton1994time}。

\(<{{\vec{s}}_{\pi+1}}^\top,{{\vec{s}}_{\pi+2}}^\top,...,{{\vec{s}}_{\pi+n}}^\top>\)

进一步地，将上式在K维主题向量上展开，得到如下所示的更为直观的多维时间序列。

\(TS(u)=<, \\
{({\omega}_{1}(\pi+1),{\omega}_{2}(\pi+1),...,{\omega}_{i}(\pi+1),...,{\omega}_{K}(\pi+1))}^\top, \\
{({\omega}_{1}(\pi+2),{\omega}_{2}(\pi+2),...,{\omega}_{i}(\pi+2),...,{\omega}_{K}(\pi+2))}^\top, \\
..., \\
{({\omega}_{1}(\pi+j),{\omega}_{2}(\pi+j),...,{\omega}_{i}(\pi+j),...,{\omega}_{K}(\pi+j))}^\top, \\
..., \\
{({\omega}_{1}(\pi+n),{\omega}_{2}(\pi+n),...,{\omega}_{i}(\pi+n),...,{\omega}_{K}(\pi+n))}^\top, \\
>\)

其中,\(i(1\le{i}\le{K})\)表示隐含主题的编号，\(j(1\le{j}\le{n})\)表示用户在当前会话期内所收听第j首歌曲的索引。显然，该多维时间序列中任意一个时间点都对应着一个K 维主题向量且对于K 维主题向量中的每一维来说又对应着一个单变量的时间序列，如下式所示。

\(TS(u,i)=<{\omega}_{i}(\pi+1),{\omega}_{i}(\pi+2),...,{\omega}_{i}(\pi+j),...,{\omega}_{i}(\pi+n)>\)

其中，\({\omega}_{i}(\pi+j)\)的含义如前所述。通过对\(TS(u,i)\)的分析可以得到用户在当前会话期内所收听的歌曲在编号为i的隐含主题上的变化情况，进而可以预测出用户可能收听的下一首歌曲在编号为i的隐含主题上的隶属度，即\({\hat{\omega}}_{i}(\pi+n+1)\)。 进一步地，我们可以获得用户行为在其他隐含主题上的变化情况并估计出用户可能收听的下一首歌曲在其他隐含主题上的隶属度。通过对K 个估计值的组合，可以得到如下所示的目标主题向量，即用户可能收听的下一首歌曲的估计主题向量。

\({\hat{\vec{s}}}_{\pi+n+1}=({\hat{\omega}}_{1}(\pi+n+1),{\hat{\omega}}_{2}(\pi+n+1),...,{\hat{\omega}}_{i}(\pi+n+1),...,{\hat{\omega}}_{K}(\pi+n+1))\)

\section{相似度计算}

通过隐含狄利克雷主题建模我们得到了如式3.7所示歌曲集S中歌曲对应的主题权重向量，考虑到向量中每一维度的值表征歌曲隶属于某一隐含主题的概率，我们将这些主题权重向量看作是离散的概率分布。进一步地，通过对多维时间序列的分析和预测，我们得到了如式3.11所示用户c可能收听的第(n+1) 首歌曲对应的主题权重向量的估计向量，即一个估计概率分布。这样，我们便可以计算歌曲集中的歌曲对应的概率分布与这个估计概率分布的距离。显然，如果s与距离足够小，那么我们就可以将歌曲s 推荐给用户c。因此，我们可以用s与的距离的倒数表示歌曲集中任一歌曲s对用户c的推荐度，即上文定义的效用函数utility(u,s)，如式3.12所示。

\(utility(u,s)=\frac{1}{1+dis(s,\hat{s})}\)

因为我们是通过主题模型建模将歌曲表示成离散的概率分布，所以我们可以使用KL距离(Kullback-Leibler Divergence)~\cite{kullback1951information}以及Hellinger距离~\cite{oosterhoff2012note}等来度量两首歌曲之间的距离。考虑到KL 距离不具有对称性，本文采用Hellinger距离来度量歌曲之间的距离，如式3.13所示。

\(dis({s}_{i},{s}_{j})=\frac{1}{\sqrt{2}}\sqrt{\sum_{k=1}^{K}({\sqrt{{\omega}_{ik}}-\sqrt{{\omega}_{jk}}})^{2}}\)


其中，\(dis({s}_{i},{s}_{j})\)为编号为i和j的歌曲对应的主题概率分布之间的Hellinger距离，K为隐含主题数目，\({\omega}_{ik}\) 为编号为i的歌曲在第k个隐含主题上的隶属程度。显然，当两首歌曲越相似，那么其对应的距离越小。相反的，若两首歌曲越不相似，其主题概率分布对应的距离越大。

\section{推荐列表生成}

最后，我们根据效用函数计算S中所有歌曲的效用值，然后根据效用值对歌曲排序，并将排名最高的N首推荐给用户，这样我们就为用户u推荐了一个长度为N的歌曲列表供用户选择。

\section{实验设计和结果}

本节我们将通过实验来验证本文所给的基于多维时间序列分析的音乐推荐方法的有效性，包括实验的设计思路、实验结果以及结果分析等内容。

\subsection{数据收集}

通过对基于多维时间序列分析的音乐推荐算法的分析，可以看出我们需要的数据集主要包括包含标签文本信息的歌曲数据集以及用户在一定会话周期内所收听的歌曲序列的数据集。虽然Berenzweig等人于2003年从Art of the Mix(http://www.artofthemix.org/)上抓取了播放列表数据集~\cite{berenzweig2004large}，但是其存在如下三个问题：

\begin{enumerate}
\item 缺少歌曲对应的标签等文本信息。
\item 歌曲名称经过处理,无法与Last.fm对应，导致可用数据较少。
\item 给出的播放列表意义不清，没有时间信息，无法确定是用户在一个会话周期内的行为，可能跨越多个会话周期。
\end{enumerate}

为此，我们从Last.fm上重新爬取了一个数据集。该数据集既包含歌曲的基本信息(包括标签等文本信息)也包含用户的基本信息(包括用户在一定会话周期内所收听的歌曲列表)。为了消除噪音，我们只选用包含歌曲数目多于10首的列表，出现频次大于10的标签以及可用标签大于4 的歌曲。该数据集的统计信息如表3.2 所示，目前该数据集已经发布在http://lastfmseq.sinaapp.com/上，而其使用说明如附录1所示。

\begin{table}[!hbp]
\caption{数据集的统计信息}
\centering
\begin{tabular}{|c|c|}
\hline
听歌事件 & 34930 \\
\hline
歌曲总数 & 24992 \\
\hline
用户总数 & 1530 \\
\hline
歌手总数 & 5479 \\
\hline
最大长度 & 10 \\
\hline
最小长度 & 30 \\
\hline
平均长度 & 22.83 \\
\hline
\end{tabular}
\end{table}

\subsection{评测标准}

对于用户u，我们通过对其收听记录所形成的有序列表进行分析，为其生成一个包含N首歌曲的推荐歌曲列表，如果这N首歌曲中包含用户真实收听的下一首歌曲，那么我们认为这个对于用户u的推荐是有效的。显然，类似音乐推荐这种为用户推荐一组物品供选择的问题是典型的Top-N推荐问题(Top-N Recommendation, TNR)。由文献~\cite{adomavicius2005toward}~\cite{powers2011evaluation}可知，召回率(recall) 和准确率(precision)是衡量一个Top-N推荐算法优劣的重要标准，我们这里也用这两种标准来评测本文提出的方法。记R(c)是根据用户在训练集上的行为给用户推荐的歌曲列表，而T(c)是用户在测试集上的行为列表，那么表征“检索出的相关文档数和文档库中所有的相关文档数的比率”的召回率Recall 的定义如式3.14 所示。

\(recall=\frac{\sum_{u\in{U}}|R(u)\cap{T(u)}|}{\sum_{u\in{U}}|T(u)|}\)

可以看出，召回率表征用户真实收听的歌曲被推荐的数目与用户真实收听歌曲总数的比率。因为在音乐推荐系统中，用户c同一时刻在测试集上只会收听一首歌曲，即|T(u)|=1。 因此，我们将式(18)简化为如式3.15 所示的命中率(hit ratio)。

\(hitRatio=\frac{\sum_{u\in{U}}hit(u)}{|U|}\)

其中，N为推荐系统为用户推荐的歌曲数目，hit表示用户实际收听的歌曲是否在推荐列表中，若在则为1，否则为0。如果hit为1，我们称之为“命中一次”。记用户u 实际收听的歌曲为s，则hit可表示为如式3.16。

\(
hit(u)=\left\{
\begin{aligned}
1   ,s\in{R(u)} \\
0   ,s\notin{R(u)}
\end{aligned}
\right.
\)

准确率表征了“检索出的相关文档数和系统所有检索到的文件总数的比率”，即用户真实收听的歌曲被推荐的数目与被推荐的歌曲总数的比率，其定义如式3.17所示：

\(precision=\frac{\sum_{u\in{U}}|R(u)\cap{T(u)}|}{\sum_{u\in{U}}|R(u)|}\)

考虑到|T(u)|=1，式3.17可简化为式3.18。

\(precision=\frac{\sum_{u\in{U}}hit(u)}{\sum_{u\in{U}}|R(u)|}\)

考虑到召回率和精确度此消彼长的关系，文献[21]中使用F1-Score对模型进行评估，F1-Score的取值越大那么模型对应的综合效果越好，反之越差。F1-Score可以用式3.19表示：

\(F1=2*\frac{recall*precision}{recall+precision}\)

在如上所述的评测标准中，召回率和准确率的在很大程度上取决于如式(19)所示的命中率。如果歌曲未被用户喜欢或收听，那么就认为该歌曲未命中。然而，文献~\cite{su2013personalized}指出没有明显的证据表明未被评分的物品对用户来说是完全否定的。也就是说，即使歌曲未命中，也不代表用户不喜欢该歌曲。假设用户u 真实收听的下一首歌曲为，如果系统为其推荐了列表，那么我们认为该推荐是有效的，因为目标歌曲在推荐列表中。相反，如果系统为其推荐列表，由于其中未包含，我们认为该推荐是无效的。然而，如果与L2中的歌曲相似度很高，用户显然也会喜欢该列表。那么，认为列表L2无效就不够合理。为了解决这种矛盾，我们可以考虑使用推荐偏差的大小来衡量算法的优劣。也就是说，推荐偏差越小，算法越好，反之越差。这里的偏差可以用歌曲对应的主题概率分布的Hellinger距离来表示。如果一个推荐列表中歌曲与目标歌曲的相似度较高，那么该列表中歌曲与目标歌曲的距离就应该较小，即推荐偏差较小，这时即使目标歌曲不在该列表中，我们也应该认为该列表合理。而如果一个推荐列表中的歌曲与目标歌曲的相似度整体偏低，导致推荐偏差较大，即使其中包含目标歌曲，我们也应该降低该列表被认可的权重。推荐系统主要包含评分预测和Top-N推荐两类问题，在评分预测中我们常常使用均方根误差(RMSE)和平均绝对误差(MAE)来衡量算法的优劣，这里我们将其借鉴到音乐推荐的问题中并用以衡量不同算法的优劣，其定义如式3.20和3.21所示。

\(RMSE=\sqrt{\frac{\sum_{u\in{U}}{e(u)}^{2}}{|U|}}\)

\(RMSE=\sqrt{\frac{\sum_{u\in{U}}|e(u)|}{|U|}}\)

其中，U为测试用户集，|U|为用户数，e(u)为向用户推荐的结果的误差。考虑到我们为用户推荐的是一个列表，我们将e(u)看做是列表中所有歌曲与目标歌曲的平均距离。如式3.22 所示。

\(e(u)=\frac{\sum_{u\in{U}}dis(s,{s}_{\pi+n+1})}{|R(u)|}\)

\subsection{实验设置}

为了客观地衡量本文所述方法的效果，我们首先将所有数据随机地分为10份并将其中的9份作为训练集，剩余的1份为测试集，然后进行10轮交叉实验。最后，我们将10轮实验的结果进行平均，从而得到最终的实验结果。其中，本文将隐含主题数目设为30。本文实验实在Dell Optiplex74的台式机上进行，操作系统为Ubuntu12.04，CPU为Intel 酷睿2 E6300，内存大小为2G，硬盘空间160G。实验所用编程语言为Python2.7。

\subsection{结果分析}

图3.4展示了当被推荐歌曲数目N由1到100的增长过程中，不同推荐算法的召回率的变化情况，这里包括基于用户的协同过滤算法(UserKNN)~\cite{resnick1994grouplens}、 基于模式挖掘的推荐算法(PatternMining)~\cite{hariri2012context}、基于马尔科夫模型的推荐算法(1st-Markov)~\cite{mcfee2011natural}、基于全局特征的推荐算法(Global) ~\cite{chordia2008extending}、 基于用户即时行为的音乐推荐(Local)~\cite{hyung2012music}以及本文提出的基于时间序列分析的音乐推荐方法(Music Recommendation Based on Time Series Analysis, MTSA)。 其中，横坐标表示被推荐歌曲的数目，纵坐标表示算法的召回率。由图3.4 可以看出，代表本文所述方法的曲线与其他曲线能够明显分开且位于其他曲线之上，表明本文所提方法能够获得比其他同类工作更好的召回率且提升效果比较明显。此外，随着被推荐歌曲数目的增加，本文所述方法的召回率也同时提升且呈逐渐上升趋势。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/hitratio.eps}
\caption{不同推荐算法在命中率上的表现}
\label{fig_hitratio}
\end{center}
\end{figure}

图3.5展示了随着推荐列表长度增加，不同推荐算法的推荐准确度变化情况。从图中可以非常直观地看出，虽然随着推荐列表长度的增加，所给几种推荐算法的准确度都有所下降，但本文所给出的基于时间序列分析的音乐推荐算法能够取得最好的推荐准确度。需要说明的是，随着推荐列表长度的增加，各算法推荐准确度取值比较低且持续下降是可以从准确度的定义中推导出来的。假设用户数目为100，推荐列表长度为50，推荐算法的命中率为60\%即命中数为60，那么此时的推荐准确度为 0.012。当推荐列表长度增加到100 时，假设推荐算法的命中率提升到80\%即命中数为80，那么此时的推荐准确度只有0.008。简单来说，对于音乐推荐来说，准确度定义中的分子变化很小且取值也很小但分母却增长地比较快，所以导致了推荐准确度取值很小且随着推荐列表长度增加，准确度不断下降。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/precision.eps}
\caption{不同推荐算法在准确度上的表现}
\label{fig_precision}
\end{center}
\end{figure}

为了更为直观地考察本文所提方法在推荐准确度指标上的提升效果，我们下面使用相对指标进行评测。考虑到基于用户的最近邻算法(UserKNN)在同类工作中的召回率最高，本文考察基于时间序列分析的音乐推荐方法相较于UserKNN在推荐准确度上的提升效果(倍数)，如图3.6所示。其中，横坐标表示被推荐歌曲的数目，纵坐标表示算法推荐准确度的提升倍数。如果纵坐标取值大于零，表明本文所述方法的推荐准确度相较于UserKNN算法有所提升；如果纵坐标取值为零，表明效果没有提升；如果纵坐标取值小于零，表明本文所述方法不但没有提高推荐准确度而且还有所下降。由图3.6可以看出，无论被推荐歌曲数目为何值，纵坐标取值总是大于零，说明本文所述方法能够提升推荐的推荐准确度且提升幅度在80\% 以上。随着推荐列表长度的增长，提升的幅度也继续增长(可达150\%)。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/improvement.eps}
\caption{本文方法相对于UserKNN在F1-Score指标上的提升}
\label{fig_improvement}
\end{center}
\end{figure}

图3.7和3.8展示了随着推荐列表长度的增加，几种不同的音乐推荐算法的均方根误差(如图3.7所示)和平均绝对误差(如图3.8所示)的变化趋势。其中，横坐标表示被推荐歌曲的数目，纵坐标表示不同推荐算法的误差。由图可以直观地看出，本文所提方法的推荐误差较之其他几种算法都比较小。随着推荐列表长度的增加，列表中无效的歌曲增多，使得推荐误差有所上升，但这种上升幅度也是是非常小的。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/rmse.eps}
\caption{不同推荐算法在均方根误差上的表现}
\label{fig_rmse}
\end{center}
\end{figure}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/mae.eps}
\caption{不同推荐算法在绝对误差上的表现}
\label{fig_mae}
\end{center}
\end{figure}

综合以上实验结果可以看出，无论是从命中率的角度去考察算法的优劣，还是从误差的角度去考察算法的优劣，本文所述的基于多维时间序列分析的音乐推荐算法都能够取得比较好的效果。这验证了本文所提方法的合理性，说明在音乐推荐系统中使用隐含特征的方法刻画歌曲并结合对用户在一个会话周期内行为趋势的预测能够提高推荐的效果。

\chapter{一种基于用户三期行为的综合音乐推荐方法}
\label{C:intergrated}

\section{问题分析}

\section{常用综合策略}

\subsection{整体式综合}

\subsection{并行式综合}

\subsection{流水线式综合}

\section{方法详述}

\subsection{方法框架}

\subsection{方法选取}

\subsection{方法综合}

\section{实验结果}

\section{分析讨论}

\chapter{系统实现}
\label{C:system}

前述章节介绍了本文所述的基于多为时间序列的个性化音乐推荐方法和基于用户三元特种的混合推荐框架，并从实验的角度验证了本文所提方法和框架的有效性。为了进一步验证本文所提方法和框架的可行性，本文实现了一个个性化音乐推荐原型系统，本章将详细介绍该系统的实现细节。

\section{系统架构}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/xlvector.eps}
\caption{推荐系统和网站其他系统之间的关系}
\label{fig_xlvector}
\end{center}
\end{figure}

尽管优秀的推荐算法能够为用户推荐合理的结果，但只靠推荐很难构成一个完整的可用系统。要构建一个可用的推荐系统，比如一个电影推荐网站，就需要考虑推荐与系统其他组件的关系，只有这样才能最终实现推荐的价值。项亮在文献~\cite{xlvector2012}中给出了如上图所示的一般意义上推荐系统和网站其他系统之间的关系。首先，基本上所有的网站都配有一个用户界面，即UI系统，该系统主要用来向用户展示页面效果以及与用户进行交互。其次，网站往往还会配置日志系统，该系统主要用来将用户在用户界面上的各种有效行为记录下来并保存到对应的日志存储系统中。需要注意的是，这里的日志存储系统既可以是数据库，也可以说是缓存，还可以是文件系统。推荐系统作为一个网站的核心，其主要作用是分析存储在日志存储系统中的用户行为历史，在此基础上生成该用户对应的推荐列表并将结果直接展示到用户界面上以供用户体验。由上图可知，推荐系统要想将强大的作用发挥出来，还要依赖于用户的历史行为信息和用户界面。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/system.eps}
\caption{原型系统框架}
\label{fig_system}
\end{center}
\end{figure}

上图虽然给出了一般意义上的推荐系统的架构，给本文所实现的系统原型带来了很大启发，但这种架构显然过于简单，不能直接用于本文的系统原型。在认真分析本文所提推荐框架组成的基础上，本文按照下图对系统原型进行设计。

本文所实现的原型系统主要包括客户端、用户服务接口、处理层和数据层构成。客户端对应于上图中的UI 系统，旨在为用户提供一个可以收听推荐歌曲并产生交互的窗口，具体到实现上既可以使用Web，也可以是Mobile还可以是普通的窗口客户端。

用户服务接口用于将用户在客户端上的行为传递给后续模块进行处理以及从将推荐的结果返回给客户端。

处理层主要用于完成相关数据处理，其包括在线处理模块和离线处理模块。其中，离线处理模块主要包括从百度音乐、豆瓣音乐、虾米音乐、Lastfm等数据源爬取歌曲基本属性数据和标签数据的爬虫系统对歌曲对应的文档集合进行语义分析以获取每一首歌曲对应的隐含主题分布的语义分析模块。需要强调的是，这里离线的含义是指该模块的工作与用户行为无关，在具体实现上可以设定一定的时间间隔或周期执行一次。

在线处理模块主要用于实时记录和处理用户的行为并为之生成最终推荐结果，其主要包括日志系统、序列生成系统、标签系统以及Storm推荐引擎几个部分组成。日志系统对应于文献中的日志系统，用于将用户的行为记录到数据存储系统中以待后续分析。标签系统主要用于记录用户对当前所听歌曲所标注的标签，其与离线模块中的爬虫系统一起生成最终的歌曲标签信息，一定周期后可供语义分析模块处理。序列生成系统用于根据用户在当前会话期内的行为生成对应的歌曲序列。Storm推荐引擎模块的主要作用是使用Storm 对用户当前会话期的歌曲序列进行实时分析并产生最终的推荐结果。

数据层主要完成用户属性、歌曲属性以及用户行为的存储功能，其包括数据库接口DAO以及具体数据库两部分。其中，数据库接口提供供其他层次模块调用的方法以避免直接操作数据库，增强了独立性。具体数据库即真实的数据存储引擎，既可以是Mysql，也可以是Oracle，当然也可以是SQLServer。
　　　
用户产生一个积极行为到系统为其推荐歌曲的过程如下所示：

\begin{enumerate}
\item 用户在客户端产生“即将收听完当前歌曲”的行为。

\item 用户服务接口接收用户的当前行为状态并将该状态传递给在线处理模块中的日志系统和序列生成系统。

\item 日志系统将用户当前行为状态通过数据库接口DAO记录到数据库中。

\item 序列生成系统通过数据库接口DAO读取日志数据库中的用户行为，构建其在当前会话期的收听序列并将该序列传递给Storm推荐引擎。

\item 推荐引擎对用户当前会话期的收听序列进行分析和处理，生成推荐列表并通过数据库接口保存到数据库。

\item 用户服务接口通过数据库接口从数据库中读取推荐列表。

\item 用户服务接口将推荐列表展示给用户。
\end{enumerate}
　　　
用户对歌曲打标签的执行过程如下所示：

\begin{enumerate}
\item 用户在客户端选定一首歌曲。

\item 用户为选定歌曲打标签。

\item 用户服务接口接收用户的打标签行为以及打标签的对象和标签内容并将它们传递给在线处理模块中的标签系统。

\item 标签系统对标签进行分析和处理。

\item 标签系统将处理过的内容通过数据库接口DAO保存到数据库中。
\end{enumerate}
　　　
类似地，可以给出用户其他行为的处理过程。

\section{离线处理模块}

如上所述，离线处理模块所做的工作主要包括爬虫系统和语义分析系统两部分组成，这些工作都是独立于用户进行的，所以称之为离线。本节将详细介绍上述框架中的离线处理模块中设计的一些技术和工具，而作为算法核心的语义分析模块将是介绍的重点内容。

\subsection{爬虫系统}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.5\textwidth]{figures/crawlSpider.eps}
\caption{爬虫系统工作流程图}
\label{fig_spider}
\end{center}
\end{figure}

网络爬虫是一种能够按照一定地规则自动地抓取互联网上的网页并对网页内容进行解析的网络机器人，又称之为网络蜘蛛。本文所实现的音乐网络爬虫首先从豆瓣、虾米、百度等音乐网站上抓取相关歌曲网页，然后对网页的HTML 进行分析和解析，进而得到歌曲的名称、创作者、发行时间、歌词等基本属性以及用户对歌曲所打的标签内容，最后将这些内容进行整理并保存到数据库中。对于一个待抓取的歌曲页面URL，本文按照如下流程图进行工作。

网络爬虫目前已经广泛应用在数据挖掘、搜索引擎、信息检索、推荐系统等领域，同时也出现了很多网络爬虫框架以简化爬虫的实现。其中，Scrapy~\cite{Scrapy}是一种纯python 实现且构建于异步框架 twisted 之上爬虫框架，其用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。要想创建一个网络爬虫，人们只需要执行命令scrapy startproject projectname就可以得到如下图所示的项目目录，可见生成的目录包含若干文件，即Scrapy 的模块。用户只需要在对应的文件中实现相应文件即可。其中，items.py文件对应于Scrapy中的项模块，用于定义抓取结果中单个项所需要包含的所有内容，如歌曲的名称、创作者、发行时间等；piplines.py对应于Scrapy中的管道模块，定义如何对抓取到的内容进行再处理，例如输出文件、写入数据库等；spider目录下存放写好的爬虫实际抓取逻辑。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.5\textwidth]{figures/scrapy.eps}
\caption{Scrapy结构示意图}
\label{fig_scrapy}
\end{center}
\end{figure}

由上可知，在抓取指定网页内容之后需要对网页进行解析，这里我们使用Python语言的第三方包BeautifulSoup~\cite{BeautifulSoup}来解析下载下来的歌曲网页对应的HTML文件。BeautifulSoup 使用起来非常简单，可以非常容易地完成对HTML文件的解析，同时它也支持按照不同的条件来查找相关元素，比如按标签查找、按属性查找、按名称查找、按结构查找等。

\subsection{结巴分词}

由信息检索等相关知识可知，要对文本进行分析，往往首先需要进行分词，即将连续的字序列按照一定的规范重新组合成词序列的过程。比如将句子“南京市长江三桥”分成“南京/市长/江三桥”或者“南京市/长江/三桥”这样的词汇序列。目前，学术界和工业界也出现了众多成熟的分词工具，比如基于词频词典的机械中文分词引擎SCWS、中科院的汉语词法分析系统ICTCLAS(Institute of Computing Technology, Chinese Lexical Analysis System)、基于HTTP 协议的开源中文分词系统HTTPCWS以及支持多种分词模式的结巴分词等。考虑到各工具的效率、可用性、精度以及源码获取难易程度，本章所述原型系统采用结巴分词作为分词工具。

结巴分词~\cite{Jieba}是一个基于Python语言开发的开放源代码的中文分词工具，其由百度(Baidu Inc.)的Sun Junyi开发并发布在Github上，其目标是“做最好的Python中文分词组件”。结巴分词自从2012年10月7日被发布到pypi以来不断地被改进和完善，目前已经发布的最新版本为0.32。其所采用的算法如下所示：

\begin{enumerate}
\item 基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG)。

\item 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合。

\item 对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法。
\end{enumerate}

总得看来，结巴分词之所以能够被广泛关注和使用，主要是因为其具有以下特点：

\begin{enumerate}
\item 安装简单。用户可以直接通过“easy\_install jieba”或者“pip install jieba”进行安装，就行安装普通的Python包一样。

\item 使用简单。用户只需使用一句代码即可实现分词操作，如用户通过如下代码即可将句子“南京市长江三桥”分词若干词汇序列并将词汇保存到列表中。

\begin{verbatim}
seg_list = jieba.cut("南京市长江三桥")；
\end{verbatim}


\item 支持多种分词模式。结巴分词支持三种分词模式，即精确模式、全模式和搜索引擎模式。其中，精确模式试图将句子最精确地切开，适合文本分析；全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。

\item 支持多种操作。除了基本的分词之外，结巴分词还支持添加自定义词典、关键词提取、词性标注、并行分词、繁体分词以及Tokenize等功能。

\item 支持多语言。除了最基础的Python语言版本外，目前结巴分词还支持Java、C++以及Node.js三种语言且源码均已发布到Github上。
\end{enumerate}

\subsection{Gensim软件包}

为了得到每一首歌曲在隐含主题上的概率分布，我们使用以LDA为代表的主题模型分析方法对每首歌曲对应的文档进行分析，这里的文档是由用户为歌曲标记的标签构成。LingPipe~\cite{LingPipe} 和Mallet~\cite{Mallet}都是非常优秀的自然语言处理软件包，但考虑到它们比较复杂且对LDA的实现欠佳，我们选择使用另一个优秀的软件包Gensim~\cite{Gensim}。Gensim 最初是作为一组被用在捷克数学文献存取网站dml.cz中的Python脚本的集合而出现，而其功能只是简单地根据给定的文档来生成一组近似的文档，Gensim正是“Generate Similar”的简称。为了使用隐含语义的方法对文档分析，作者于2010年将其扩展为一个Python包，随后作者于2011年开始使用Github来管理源代码并于2013年设计了Gensim独特的Logo和网站。Gensim 可以非常方便地实现主题模型，正如其介绍中所说―“为人类而设计的主题模型开发包”，其主要具有以下特点：

\begin{enumerate}
\item 可扩展性。Gensim通过使用增量式的在线训练方法可以处理大规模的语料库，从而不需要将所有语料一次性装入内存，降低了内存的负担，增强了可扩展性。

\item 平台无关性。Gensim是纯Python实现，可以运行在Linux、Windows、OS X以及其他支持Python和Numpy的平台上。

\item 鲁棒性。Gensim已经被很多个人和组织应用在各种系统中超过四年，早已过了一个开源项目的“妈妈，我发布了一个脚本”的初始阶段。

\item 开源性。Gensim开放源代码，其使用GNU LGPL许可证，允许个人和商业机构使用和修改该项目。

\item 高效性。Gensim中的各种算法都是使用经过优化的方法进行实现的，使得算法的效率较高；另外，Gensim实现了一些算法的分布式版本，使得算法可以并行执行或者在集群上执行，进一步增加算法的执行效率。

\item Gensim包含对一些常用数据格式的高效内存实现方式，同时支持不同数据格式之间的转换。

\item Gensim除了可以快速地执行主题模型建模，还提供了快速计算文档相似性的方法。
\end{enumerate}
　　　
下面简单介绍以下使用Gensim软件包进行LDA建模的方法和流程：

\begin{enumerate}
\item 准备语料库，这里就是需要进行主题模型建模的文档集合。

\item 对文档集合中的每一篇文档进行分词并利用分词的结果构造词典，同时可以得到每个词或者词组在词典中的编号。

\item 词典生成好之后就生成语料库，语料库中的每一个语料与文档集合中的每一篇文档一一对应，而语料的表示形式即是文档的向量空间模型，即词典中的某个词或词组在该文档中出现的次数。

\item 将上述向量空间模型表示的语料库转换成TF-IDF模型表示的语料库，即此时得到的语料库可以表征每一个词或者词组的重要程度。

\item 进行LDA主题模型建模，得到建模结果。
\end{enumerate}

\section{在线处理模块}

\subsection{序列生成}

用户在当前会话期内收听的歌曲序列是本文所述方法和框架的输入，本节将介绍序列生成系统是如何根据用户的行为生成这种序列的。需要强调的是，作为输入的序列是用户产生积极行为的歌曲序列，下面将给出对于积极行为的定义。

用户在收听一首歌曲的时候，可能对其产生两种典型的行为，即积极行为和消极行为。典型的积极行为包括用户收藏当前歌曲、分享当前歌曲、完整收听或者收听当前歌曲的绝大部分等，而典型的消极行为包括用户将歌曲丢进“垃圾桶”、选择跳过当前歌曲、只收听当前歌曲的一小部分等。对于收藏、分享、丢进“垃圾桶”、跳过这些比较直观地行为我们不再做进一步描述，而对于用户收听歌曲比例所表达的态度，本文认为如果用户收听当前歌曲的长度超过了歌曲总长度的50\%那么用户喜欢该歌曲，否则认为用户不喜欢当前歌曲，即消极行为，如下式所示。其中，total\_length表示歌曲的总长度，past\_length表示用户收听该歌曲的时间长度，而pastRatio表示用户收听长度占歌曲总长度的比例。Attitude表示用户对歌曲的态度，当pastRatio不小于50\%时取值为1表示积极态度，否则表示消极态度。假如歌曲“大海”总长度为4分40秒，即280000毫秒，用户a收听至1分钟即60000毫秒时跳过，那么对应的pastRatio(a，“大海”)=21.43\%，那么我们认为用户a不太喜欢歌曲“大海”，而用户b收听至4分钟即240000毫秒时跳过，那么对应的有pastRatio(b，“大海”)=85.71\%，我们认为用户b比较喜欢当前歌曲。至于用户为什么没有听完整整首歌曲，即pastRatio(b,”大海”)不等于1，可以认为用户收听的时间过长，想要换一首。序列生成系统在歌曲播放至50\% 时便读取数据库中保存的用户当前会话期内的积极歌曲序列，并结合当前歌曲组成新的序列传递给推荐引擎。

\(pastRatio(user,song)=\frac{past_length}{total_length}\times{100\%}\)

\(attitude(user,song)=
\left\{
\begin{aligned}
1    ,pastRatio(user,song)\ge{50\%} \\
0    ,pastRatio(user,song)<50\%
\end{aligned}
\right.\)

\subsection{推荐引擎}

在由5.4中的序列生成系统得到用户当前会话期的收听列表后，图所述的系统框架则激活基于Storm框架的推荐引擎去读取列表进行处理并生成最终的推荐列表。之所以使用Storm 框架是因为音乐推荐系统是一个对实时性要求比较高的系统，需要及时地为用户生成推荐结果，而Storm恰恰是这样一个开源的且面向实时性处理的分布式框架。第二章中已经简单介绍了Storm以及对应的DRPC的基本内容，本节将介绍本文所实现的原型系统是如何利用的，对应的拓扑图如下所示。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/topology.eps}
\caption{推荐引擎工作拓扑结构图}
\label{fig_topology}
\end{center}
\end{figure}

\begin{enumerate}
\item 推荐引擎通过数据库接口DAO从数据库中读取用户当前会话期内的歌曲列表。

\item 读取共享内存中每一首歌曲隶属于每一个隐含主题的概率，进而将1中的序列分割成K个子序列。其中，每一个子序列代表一个隐含主题，取值为歌曲在该主题上的隶属概率。这样，我们可以得到K个子序列。

\item 对2中的K个子序列进行时序预测，预测期下一个取值，即用户可能收听的歌曲在该主题上的隶属度。

\item 将K个主题上的预测值汇总，得到下一首歌曲的完整概率分布。

\item 计算曲库内所有歌曲与该歌曲的相似度。

\item 将5中的相似度按照由大到小的顺序排列，并取前10作为推荐列表。

\item 将推荐列表返回。
\end{enumerate}

构建了上述拓扑结构并实现后，下面需要做的就是将其部署到服务器上，具体的部署过程如下所示。

\begin{enumerate}
\item 启动zookeeper。Zookeeper 分布式服务框架主要是用来解决分布式应用中经常遇到的一些数据管理问题，如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。Nimbus和Supervisor节点之间所有的协调工作是通过Zookeeper集群来实现的。

　　　zkServer.sh start

\item 启动nimbus。主控节点（Master Node）上运行一个被称为Nimbus的后台程序，它负责在Storm集群内分发代码，分配任务给工作机器，并且负责监控集群运行状态。Nimbus 的作用类似于Hadoop中JobTracker的角色。

　　　storm nimbus

\item 启动supervisor。每个工作节点（Work Node）上运行一个被称为Supervisor的后台程序。Supervisor负责监听从Nimbus分配给它执行的任务，据此启动或停止执行任务的工作进程。每一个工作进程执行一个Topology的子集；一个运行中的Topology由分布在不同工作节点上的多个工作进程组成。

　　　storm supervisor

\item 启动UI。storm UI是一个可以查看storm运行状态的的一个网站，可以查看Topology的执行状态。

　　　storm ui

\item 启动drpc。通过DRPC，其他机器可以远程执行Topology。

　　　storm drpc

\item 提交topology。将实现好的Topology提交至Storm集群进行执行。

　　　storm jar SweetFM.jar com.wst.sweetfm.topology.DRPC\_MTSATopology sweetfm

\item 显示所有topology

　　　storm list

\item 杀死指定topology

　　　storm kill sweetfm
\end{enumerate}

mithunsatheesh给出了一种使用PHP远程调用Storm集群中运行的Topology的方法，如下表所示。

include "includes/drpc/DRPC.php";

\$drpc = new DRPC("xxx.xxx.x.xx",3772,NULL);

\$result = \$drpc->execute("CallFunctionName",\$params);

具体到我们的原型系统中即是：

include "includes/drpc/DRPC.php";

\$drpc = new DRPC("114.212.84.238",3772,NULL);

\$seq = “4>6>1>8>2>0”;

\$result = \$drpc->execute("sweetfm",\$seq);

首先构造一个drpc对象，然后以适当的格式给出用户在当前会话期的歌曲序列并作为参数传递给drpc对象的execute函数，Storm集群上的sweetfm接收传递过来的参数并进行计算，
计算结束之后将结果返回给result，即一个歌曲推荐列表，如”[1,2,3,4,5,6,7,8,9,10]”

\section{系统效果}

本节给出本文实现的系统原型的效果截图，如下所示。在下图中，从左上到右下共有六张效果图，分别为游客登录效果图、用户注册效果图、用户登录效果图、
系统主界面效果图、用户对歌曲打标签效果图以及用户调整播放音量效果图。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/sweetfm.eps}
\caption{原型系统效果图}
\label{fig_sweetfm}
\end{center}
\end{figure}

\chapter{总结与展望}
\label{C:conclusion}

\section{工作总结}

本文首先给出了一种基于时间序列分析的个性化音乐推荐方法，该方法综合考虑了歌曲划分标准的不确定性以及用户所处上下文环境对推荐的影响和作用。
首先，该方法利用用户给歌曲所打的标签构造歌曲对应的文档，在此基础上使用主题模型建模的方法对文档集合建模，将歌曲表示成若干隐含主题的概率分布。
其次，该方法将用户在当前会话期内所收听的歌曲序列表示成与隐含主题个数对应的多个时间序列，然后使用相关时间序列分析方法对每一个时间序列进行分
析和预测以得到用户可能收听的下一首歌曲在各个主题上的分布，最后通过计算曲库中歌曲与目标歌曲的相似度生成最终的推荐列表。在给出了基于时间序列
分析的个性化音乐推荐方法后，本文进一步分析了用户听歌行为的特点，给出了用户听歌行为具有局部性、全局性和时序性的特点，
在此基础上给出一种混合音乐推荐框架，综合考虑每一种特性的作用和影响。最后，本文给出了一个实现所述方法和框架的原型系统，
验证了本文所述方法和框架的可行性和有效性。

\section{工作展望}

\begin{enumerate}
\item 本文只是使用用户对歌曲所打的标签去构造歌曲对应的文档，下面试图使用更丰富的的文本信息表征歌曲，进而构造更符合歌曲内在特质的文档。

\item 本文所述方法主要是对用户的积极行为进行分析，下一步可以尝试假如一些否定信息。
　　　
\item 本文所述的原型系统目前仅部署在单机上，下面需要迁移到集群上以提升系统的可用性。
\end{enumerate}

  % 附录
\appendix

\chapter{数据集使用说明}
\label{C:dataset}

\section{权利声明}

本数据集抓取自Lastfm，所有数据归Lastfm所有，禁止商业用途。
如果您想使用该数据集进行科研活动，请务必给出对Last.fm及本文的引用信息。

\section{数据特点}

\begin{enumerate}
\item 包含完整的用户、歌曲、曲作者的基本信息。

\item 包含丰富的用户行为记录，可用于构造用户行为序列。

\item 包含歌曲、曲作者的显著标签信息，可用于从文本的角度描述歌曲和作者。

\item 提供了标签的基本信息。

\item 数据被随机分组，可直接用来实验。
\end{enumerate}

\section{组织形式}

本数据集使用Mysql进行管理，对应的数据库名为lastfm，您可以非常容易地将其导入并使用。数据集包含有5个基本的数据表：

\begin{enumerate}
\item 记录表record用于记录用户的收听行为，如某用户在某时间段收听了某歌曲。record由记录标识符(rid:int)、用户标识符(uid:varchar)、歌曲mbid(mbid:varchar)、记录发生的unix时间戳(uts:varchar)、记录发生的日期时间(datetime:varchar)、记录所属分组(scale:int)等字段构成。

\item 用户表user用于记录用户的基本信息，其由用户标识符(uid:varchar)、用户名(username:varchar)、用户国籍(country:varchar)、用户年龄(age:varchar)、 用户性别(gender:varchar)、用户注册时的unix时间戳(registeredTime:varchar)、 用户注册日期时间(registeredText:varchar)、播放序列(playlist:text)、 用户所属分组(scale:int)等字段构成。

\item 歌曲表song用于记录歌曲的基本信息，其由歌曲标识符(sid:varchar)、歌曲对应mbid（mbid:varchar）、歌曲名称(name:text)、 歌曲时长(duration:varchar)、曲作者标识符(aid:varchar)、曲作者名称(aname:varchar)、专辑名(album:text)、听众数目(listeners:varchar)、播放次数(playcount:varchar)、描述歌曲的显著标签(toptag:text)等字段构成。

\item 曲作者表artist用于记录曲作者的基本信息，其由曲作者标识符(mbid:varchar)、曲作者名称(name:text)、曲作者图片的链接(img:text)和描述曲作者的显著标签(toptag:text) 构成。

\item 标签表tag用于记录标签的基本信息，其由标签标识符(id:varchar)、标签名称（name:text）、标签被创建的次数(reach:varchar)、标签被使用的次数(taggings:text)等字段构成。
\end{enumerate}

\section{字段解析}


\subsection{scale}

记录表record和用户user中的scale字段用以表征记录和用户所处的分组编号。为了方便，本数据集将用户记录和用户分为Unused、Small、Whole 和Session四类。

其中，Small、Whole和Session被scale字段分割成40组，其中第0组到第9组属于Small数据集，第0组到第29 组属于Whole数据集，第30组到第39组属于Session数据集。Unused数据的scale设为-1。显然，Small数据集是Whole数据集的一部分，它们的特点是每一个用户所收听的歌曲都在一个会话期内，即不存在长时中断。从Whole数据集中划分出Small数据集的主要目的是方便机器性能不佳的用户使用，对于Small数据集，用户可以使用10组中的9组作训练集而余下的一组作测试集。Session数据集与Whole数据集的主要区别是每一个用户所收听的歌曲至少在两个会话期内。类似的，用户可以用其中9组作训练集而余下的一组作测试集。下表给出了Small、Whole和Session三类数据集的基本统计信息。
\begin{table}[!hbp]
\caption{数据集的统计信息}
\centering
\begin{tabular}{|c|c|c|c|}
\hline
 & Small & Whole & Session \\
\hline
 用户数 & 1530 & 4590 & 1690 \\
\hline
 歌曲数 & 24992 & 62422 & 32218 \\
\hline
 稀疏度 & 99.92 & 99.97 & 99.92 \\
\hline
 最大长度 & 30 & 30 & 66 \\
\hline
 最短长度 & 10 & 10 & 20 \\
\hline
 中位长度 & 24 & 24 & 30 \\
\hline
\end{tabular}
\end{table}

\subsection{playlist}

数据表user中的playlist字段用以表征用户按序收听的歌曲构成的序列，数据如“sid1:ratio1==>sid2:ratio2==>...==>sidn:ration”所示。其中，sid表示被听歌曲的标识符(注:非mbid)。ratio 表示两首歌之间的时间间隔与前一首歌曲时长的比例，用以表征用户收听该首歌曲的时长比例。显然，ratio 过小表示用户刚开始收听遍跳过，ratio过大表明歌曲被完整收听而且还可能有暂停发生。

\subsection{toptag}

数据表song和artist中的字段toptag表示Lastfm网站中的用户给歌曲或曲作者所打的显著标签，数据如“{tag1:count1,tag2:count2,...,tagn:countn}”所示。其中，tag 表示被打标签名称，count表示标签被标记次数。需要注意的是，在Lastfm中，count并非标签被应用于歌曲或曲作者的绝对次数，而是标签相对于被使用最多次的标签的相对次数。例如在描述歌曲“Collapse of History”的标签中，“industrial”被使用最多次且次数为200，而标签“Stars”被使用100次。那么，在歌曲记录对应的字段toptag中，“industrial” 对应的count为100，“Stars”对应的count为50，即{“industrial”:100,”starts”:50}，以此类推。

\subsection{其他字段}

数据表中的其他字段都比较简单直观，这里就不再一一介绍。

\section{应用场景}

\begin{enumerate}
\item 使用文本分析的方法描述歌曲或者曲作者特征。
\item 分析用户所收听歌曲的序列，包括跨会话分析和会话内分析。
\item 预测用户下一首可能收听的歌曲或者曲作者。
\item 生成用户可能喜欢的播放列表。
\item 标签预测问题。
\item 其他适合的应用场景。
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 附件部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter

% 参考文献
% 使用 BibTeX，不使用 BibTeX 时注释掉下面一句。
\bibliography{template}

% 不使用 BibTeX
%\begin{thebibliography}{2}
%
%\bibitem{deng:01a}
%{邓建松,~彭冉冉,~陈长松}.
%\newblock {\em \LaTeXe{}~科技排版指南}.
%\newblock 科学出版社,~书号:~7-03-009239-2/TP.1516, 北京, 2001.
%
%\bibitem{wang:00a}
%王磊.
%\newblock {\em \LaTeXe{}~插图指南}.
%\newblock 2000.
%\end{thebibliography}

% 本章可以删去
\Nchapter{简历与科研成果}

\noindent {\heiti 基本情况}
\vspace{1ex}

\noindent 王守涛，男，汉族，1987~年~12~月出生，安徽省阜阳市人。

\vspace{2ex}
\noindent {\heiti 教育背景}

\begin{description}[labelindent=0em, leftmargin=8em, style=sameline]

\item[2011.9～2014.6] 南京大学计算机科学与技术系 \hfill 硕士

\item[2007.9～2011.6] 合肥工业大学计算机信息学院 \hfill 本科

\end{description}

% 发表文章目录
\vspace{5ex}
\begin{Publications}{2}

\item 吕建,徐锋,王守涛. 一种基于多维时间序列分析的个性化音乐推荐系统及其实现方法:中国. 201410077177.1[P]. 2014-03-04.

\end{Publications}

  % 致谢
\begin{thanks}
\vskip 18pt

日光荏苒，在南京大学计算机与技术系软件所攻读硕士的三年行将结束，在此对在我成长道路上谆谆教导的师长以及在我生活中给予关心和帮助的同学表达由衷的谢意。

首先，感谢我的导师徐锋教授，从起始移动互联网领域的编程实践到后来推荐系统相关知识的学习与研究，徐老师都耐心地进行指导。在我工作遇到困难的时候，徐老师总是能够给出一些非常有建设性并且有远见的建议，他总是能够从比较高的层次指出工作中存在的不足，这对于我从宏观上去把握所研究的工作内容有非常大的裨益。另外，徐老师非常健康的生活方式也值得我在以后的工作和生活中认真学习。

感谢计算机系软件所的吕建教授，陶先平教授，马晓星教授，胡昊教授，黄宇副教授，许畅副教授，曹春副教授，余萍，马俊和张建莹老师等，他们在我学习和工作中给予了许多帮助。感谢和我一起努力的同学，姚远博士，张栋栋，王瑶菁，袁明珠，周昊一，陈晓宇等，在论文和项目中的鼓励和协作。感谢徐经纬博士，朱晓瑞博士在相关工作中给出的启发性见解和指导。感谢室友王海涛，王逸恺等，让我对其他研究方向有所认知，他们科研的态度也给了我很大启发，而平时和谐愉悦的宿舍生活使得我在平时的科研和学习中充满活力，这定将成为我学生生活中最美好的记忆之一。

感谢父母一直以来对我的支持和鼓励，他们为了给我创造良好的成长环境和学习环境付出了很大的心血，他们是我坚实的后盾和持续奋斗的动力，我定不辜负他们对我的期望，在以后的工作中继续努力，成就自己的一番事业。

最后，感谢我的女朋友侯小丽的坚守和付出，无论我遇到何种挫折和坎坷，她都出现在我的身边并给予我最大的支持和鼓励，我一定会持续积极上进，为以后的更加美好的生活创造条件。

\end{thanks}


\end{document}
