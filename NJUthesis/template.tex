%% Thesis Template of Nanjing University
%%   for using NJUthesis package with LaTeX2e
%%
%% Created by Wenbo Yang <http://solrex.org>
%% Homepage: http://share.solrex.org/njuthesis/
%%
%% $Id: template.tex,v 0.2 2010/05/01 Exp $


\documentclass[dvipdfm, oneside, master]{NJUthesis}
% 可选参数：
%   nobackinfo 取消封二页导师签名信息
%   oneside/twoside 单面/双面打印
%   phd/master 博士/硕士论文
% 下面三个选一个：
% dvipdfm 使用 dvipdfm(x) 生成最终的 PDF 文档 (缺省设置，不建议修改）
% dvips 使用 dvips 生成最终的 PS 文档
% pdftex 使用 pdfLaTeX 生成最终的 PDF 文档

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 导言区
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 小节标题靠左对齐
\CTEXsetup[format+={\flushleft}]{section}

% 设置链接颜色
\hypersetup{
% pdf 属性
             pdftitle={一种基于多维时间序列分析的音乐推荐系统研究与实现}, %
            pdfauthor={王守涛}
}

% 表格
\usepackage{longtable, multirow}
% 英文使用 Times 字体
\usepackage{times}
% 源代码
\usepackage{fancyvrb}
% 自定义列表样式
\usepackage{enumitem}
% 算法
\usepackage{algorithm}
\usepackage{algorithmic}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 封面部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 国家图书馆封面内容字符串
% 仅博士需要填写并保证模板参数选择了 phd
\classification{}
\confidential{}
\UDC{}
\titlelinea{南京大学学位论文}
\titlelineb{~\LaTeX{}~模板}
\titlelinec{}
\advisorinfo{南京大学~数学系}
\chairman{XXX 教授}
\reviewera{某某某某　副研究员}
\reviewerb{XXX 教授}
\reviewerc{XXX 教授}
\reviewerd{XXX 教授}
\nlcfootdate{2010~年~5~月~1~日}

% 南大中文封面内容字符串
\title{一种基于多维时间序列分析的音乐推荐系统研究与实现}
\author{王守涛}
\studentnum{~MF1133033}
\grade{2011}
\advisor{徐锋~~教授}
\major{计算机技术}
\researchfield{可信计算}
\footdate{2014~年~5~月}
\submitdate{2014~年~5~月~18~日}
\defenddate{2014~年~5~月~25~日}

% 英文封面内容字符串
\englishtitle{Research and Implementation of A Music Recommender System Based on Multidimensional Time Series Analysis}
\englishauthor{Shoutao Wang}
\englishadvisor{Professor Xu Feng}
\englishinstitute{Computer Technology}
\englishdegree{Master}
\englishmajor{Computer Technology}
\englishdate{May 2014}

% 制作封面命令
\maketitle

% 制作英文封面命令
\makeenglishtitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 前言部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frontmatter

% 中文摘要
\begin{abstract}
　　近年来，移动互联网和智能手机的快速发展，使得音乐电台应用大量出现，比如Lastfm、Pandora、豆瓣电台等。然而，此类应用的音乐推荐算法没有充分考虑用户听歌行为与其所处
上下文环境之间的关系，导致推荐结果不够理想，而少量考虑用户上下文的工作对用户行为的时间相关性处理不够合理，同样难以达到理想的推荐效果。我们认为，用户的未来行为与其
长期行为、即时行为和中期行为均存在相关性，但目前未见工作全面考虑用户行为的时间相关性。为此，本文提出了一种基于多维时间序列分析的个性化音乐推荐方法，较合理地利用用
户中期行为提高音乐推荐效果，进而给出了一种综合用户长期、中期和即时行为的音乐推荐方法，通过原型系统的实现，初步验证了上述方法的可行性。本文的主要贡献如下：
    \begin{enumerate}
    \item 提出了一种基于多维时间序列分析的音乐推荐方法。该方法采用主题模型将每首歌曲表示成隶属于若干隐含主题的概率，进而将用户行为建模为多维时间序列并对该序列进行
    分析，从而较好地预测用户行为偏好，并给出合理的推荐。

    \item 给出了一种基于用户长期、中期和即时行为的综合音乐推荐框架，考虑了三种行为影响权重的动态调整问题，进一步提高了音乐推荐的效果。

    \item 基于上述技术实现了一个音乐推荐原型系统，为提高处理效率，系统采用分布式实时计算框架Storm实现，达到了预期效果。
    \end{enumerate}
\keywords{音乐推荐系统， 主题模型， 多维时间序列}

\end{abstract}

% 英文摘要
\begin{englishabstract}

    With the rapid growth of mobile-Internet and smart-phone in recent years, many music radio applications come to our lives, such as Last.fm, Pandora and
    douban.fm. The recommender algorithms behind most of these applications do not take the relationship between users' listening behaviors and the context
    information into consideration leading to unsatisfactory recommendations. There exist a few algorithms that take the relationship into consideration;
    however, these algorithms do not handle the time-related features of users' behaviors in a reasonable way. We believe that users' future behaviors are
    simultaneously affected by their long-term behaviors, mid-term behaviors and immediate behaviors. To make full use of these time-related features, we
    propose a music recommender method based on multidimensional time series analysis. Our method first exploits users' mid-term behavior, and then incorporates
    users' mid-term behavior with their long-term behavior and immediate behavior. Moreover, we implement a system prototype to preliminarily verify the
    feasibility of our method. Our main contributions are summarized as follows:
    \begin{enumerate}
    \item A music recommender method based on multidimensional time series analysis was proposed. The method first uses topic models to model a song as a probability
    distribution over some latent topics and then models a user's behavior as a multidimensional time series. By analyzing the time series, the method can
    forecast the user's future behaviors and get reasonable recommendations.

    \item A music recommender method based on users' long-term behaviors, mid-term behaviors and immediate behaviors was proposed. The method can dynamically adjust
    the weights of these behaviors and get better recommendations than the method purely based on multidimensional time series analysis.

    \item A music recommender system prototype based on the above methods was implemented. In order to improve the efficiency, we use Storm, a distributed realtime
    computation framework, to implement the system and achieve the desired effects.
    \end{enumerate}
\englishkeywords{Music Recommender System, Topic Model, Multidimensional Time Series}

\end{englishabstract}

% 生成目录命令
\tableofcontents

% 以下两个目录可根据具体情况注释掉
% 生成表格目录命令
\listoftables
% 生成插图目录命令
\listoffigures


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter

\chapter{引言}
\label{C:intro}

近年来，移动互联网和智能手机得到了快速发展，信息呈指数级增长，造成了严重的信息过载(Information Overload)问题~\cite{yang2003visualization}。面对海量的信息和众多的选择，
人们往往无所适从而陷入到选择悖论(Paradox of Choice)~\cite{scheibehenne2010can}之中，或无法做出合理的选择，或需要消耗很大的精力才能做出正确的选择。为了解决信息过
载问题，减轻人们在抉择时所承受的负担，信息分类、搜索引擎和推荐系统等技术应运而生，如表1.1所示。

\begin{table}[!hbp]
\caption{解决信息过载问题的主流方案}
\centering
\begin{tabular}{|c|c|c|}
\hline
名称 & 特点 & 案例 \\
\hline
信息分类 & 分门别类地组织信息 & Yahoo!、58同城 \\
\hline
搜索引擎 & 根据关键字进行查询 & Google、百度 \\
\hline
推荐系统 & 分析用户行为历史，主动推荐 & Amazon、淘宝 \\
\hline
\end{tabular}
\end{table}

信息分类技术是通过将互联网上的各种信息分门别类地组织起来来提高人们查询效率的，比如早期的Yahoo! 和国内的58同城。然而，信息分类技术往往依赖于人工，
可扩展性差。搜索引擎技术通过建立索引的方式将互联网上的网页组织起来，然后根据用户输入的关键字进行查询，比如Google 和百度。
显然，搜索引擎相对于信息分类更能够适应互联网的快速发展。然而，人们很多时候要么不愿意费时费力地去输入关键字、要么无法准确地用关键字去描述自己
的想法，比如“今天看什么电影好呢？”、“去哪儿吃饭呢？”，这限制了搜索引擎作用的发挥。为了解放人们的双手并挖掘人们的内在偏好和需求，推荐系统技术应运而生。

推荐系统本质上是一种信息过滤系统，其通过对用户行为历史的分析挖掘出用户的行为偏好，进而帮助用户将海量信息中的无用信息过滤掉并将符合用户偏好的信息推荐出来
~\cite{adomavicius2005toward}。目前，推荐系统已经在各个领域得到了广泛的应用，比如电子商务领域的亚马逊和淘宝，视频领域的Netflix和优酷，个性化音乐领域的
Lastfm~\cite{Lastfm}和豆瓣电台~\cite{DoubanFM}以及个性化阅读领域Flipboard和无觅阅读。图1.1展示了电子商务领域中Amazon的商品推荐系统界面和视频领域中PPTV的视
频推荐系统界面。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/recommender_system.eps}
\caption{Amazon电商推荐及PPTV视频推荐}
\label{fig_recommender_system}
\end{center}
\end{figure}

文献~\cite{rentfrow2003re}表明，人们在日常生活中的听歌行为要远远多于读书、看电影等行为，这说明音乐已经成为人们生活中不可缺少的一部分。音乐推荐系统正是推荐系统在
音乐领域的应用，其通过分析用户的收听习惯以及歌曲本身的特征来为用户推荐符合其需求及偏好的歌曲~\cite{song2012survey}。与传统的书籍、电影等物品相比，音乐以及人们消费音乐的方式具有如下特点：

\begin{enumerate}
\item 歌曲往往比较短，而且大多是免费的，因此人们消费音乐作品的代价比较低，可以一次性收听一组歌曲。

\item 歌曲没有确定的划分标准，流派、心情、场合、年代等都可以用来划分歌曲。比如，按照流派可以将歌曲分为流行、经典、摇滚等类别，按照心情可以分为欢快、
伤感、忧伤等类别。

\item 即使是按照一个统一的标准对歌曲进行划分，一首歌曲往往并不是确定地属于某一个类别，而是以不同的程度分属于多个类别。比如，按照流派进行划分，张雨生的经典
歌曲“大海”既属于经典也属于流行。

\item 用户在给定平台下收听歌曲时往往是按照次序一首接着一首收听的，这说明用户对音乐的消费与次序有很强的关联。

\item 用户在不同的上下文环境下对音乐作品的选择也有所不同。比如，用户在睡觉前可能倾向于收听舒缓的歌曲而在运动时倾向于收听快节奏歌曲。
\end{enumerate}

为了满足人们对音乐的个性化需求，一些音乐推荐系统被开发出来，如国外的Lastfm~\cite{Lastfm}、Pandora~\cite{Pandora}以及国内的豆瓣电台~\cite{DoubanFM}、
虾米音乐~\cite{Xiami}，图1.2展示了豆瓣电台和虾米音乐的界面。这些音乐推荐系统首先建立自己的曲库，然后分析歌曲的特征和用户的听歌习惯继而为用户做出推荐。
其中，Pandora~\cite{Pandora} 是当今最流行的音乐推荐系统之一，其通过“Music Genome Project”将400种属性分配给每一首歌曲，进而按照歌曲的相似程度为用户做出推荐。
从可见的资料看，Lastfm~\cite{Lastfm}、豆瓣~\cite{DoubanFM} 主要是根据“相似的人往往具有相似的行为”这样的假设为用户做出推荐。虾米音乐~\cite{Xiami} 在给出了推荐结果
的同时还给出了做出推荐的原因，这在一定程度上提升了用户对推荐结果的接收程度。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/douban_xiami.eps}
\caption{豆瓣及虾米音乐电台示意图}
\label{fig_douban_xiami}
\end{center}
\end{figure}

在学术界，学者们也给出了一些有效的音乐推荐算法。按照这些算法参考用户行为序列长度的长短，我们将这些算法分为全面考察用户所有收听行为的基于用户长期行为的音乐推
荐~\cite{resnick1994grouplens}~\cite{chordia2008extending}、仅考察用户当前收听行为的基于用户即时行为的音乐推荐~\cite{downie2003music}~\cite{hyung2012music}
以及考察用户在当前会话期内行为的基于用户中期行为的音乐推荐~\cite{hariri2012context}~\cite{mcfee2011natural} 三类。其中，基于用户中期行为的音乐推荐由于考虑了
上下文环境对用户行为的影响而得到了越来越多的关注。但是，以~\cite{hariri2012context}~\cite{mcfee2011natural} 为代表的基于用户中期行为的音乐推荐算法还存
在对用户行为的时间相关性分析不合理的问题，主要表现在如下几个方面：

\begin{enumerate}
\item 只能够定性地分析出目标歌曲可能隶属的类别，无法定量地给出属于该类别的程度，对用户行为的描述不够细致。

\item 只考虑了若干显著类别的影响，忽视了其他类别对用户行为的贡献和作用，对用户行为的描述不够全面。

\item 在一定程度上依赖于其他用户的行为，但很多时候其他用户的行为很难获取，导致对当前用户行为的预测效果比较差。
\end{enumerate}

为了合理地利用用户中期行为提高音乐推荐效果，本文给出了一种基于多维时间序列分析的个性化音乐推荐方法，该方法将用户行为建模为一个多维时间序列，从而实现
对用户行为细致、全面地分析。同时，该方法专注于对当前用户行为的分析而降低了对其他用户行为的依赖。

此外，本文认为用户的未来行为与其长期行为、中期行为和即时行为均存在相关性，但是目前未见工作将这三方面的影响和作用综合起来进行考虑。因此，本文进一步给出
一种基于用户长期、中期和即时行为的综合音乐推荐方法，全面考察用户行为的时间相关性。通过实验，本文验证了上述方法能够取得比参考方法更高的预测命中率以及更低的推荐误
差。最后，本文基于上述方法实现了一个原型系统并且通过分布式实时计算框架Storm在该系统中实现了本文方法的并行化，初步验证了所给方法的可行性。

本文结构按照如下方式进行组织：第2章介绍与本文工作相关的一些工作，包括常用的音乐推荐算法、常用的物品相似度计算方法、推荐系统的评测指标以及文本处理、时间序列分析的
相关理论等；第3章描述了本文所提的一种基于多维时间序列分析的个性化音乐推荐方法，包括问题的定义、方法的执行流程等；第4章描述了本文给出的一种基于用户长期、中期和即时
行为的综合音乐推荐方法；第5章介绍了本文所实现的原型系统及相关实现技术；第6章对本文工作进行总结并给出对未来工作的展望。

\chapter{相关工作}
\label{C:relatedwork}

本章我们介绍与本文相关的一些工作。首先，我们介绍音乐推荐系统领域常用的一些推荐算法、物品相似度的常用计算方法以及一些常用的算法评估标准。然后，我们介绍文本
建模、时间序列分析以及实时流处理框架的相关工作，这些方法和技术将在本文后续工作中得到应用。

\section{音乐推荐算法}

目前，音乐推荐系统领域的研究工作已经取得了长足的进步，出现了很多音乐推荐算法。要想为用户推荐合适的歌曲，大部分音乐推荐方法都要对用户的听歌行为进行分析。按照推荐算法
对用户行为的参照程度，我们将这些音乐推荐方法分为基于用户即时行为的音乐推荐、基于用户长期行为的音乐推荐和基于用户中期行为的音乐推荐。本节对这三类推荐方法进行介绍。

\subsection{基于用户即时行为的音乐推荐}

基于用户即时行为的音乐推荐是最为朴素的一种音乐推荐方法，此类音乐推荐算法认为用户的状态在短期内保持稳定，而用户可能收听的下一首歌曲与用户当前收听的歌曲具有类似的
特征。假如用户正在收听老狼的《同桌的你》，此类算法首先通过一定的方式抽取歌曲对应的特征，并在此基础上将与《同桌的你》具有相似特征的歌曲推荐给用户，
比如老狼的另一首经典校园民谣《睡在我上铺的兄弟》，豆瓣电台的“听相似歌曲”实现的正是这样一个功能。因此，以何种方式抽取歌曲特征就成了此类音乐推荐算法工作的关键。
文献~\cite{downie2003music}充分利用歌曲的编辑属性，将与当前歌曲具有相同或相似曲作者、歌曲名称以及歌词的歌曲推荐给用户。
文献~\cite{bogdanov2011unifying}~\cite{cano2005content}~\cite{mak2010similarity}使用歌曲的声学特征为用户做出推荐，将与当前歌曲具有相似节奏、韵律、音色的歌曲推荐给
用户。文献~\cite{kim2010music} 使用心情特征对歌曲进行刻画并将与当前歌曲具有近似心情属性的歌曲推荐给用户。这些工作都是从单一方面对歌曲进行刻画并进而为用户做出推荐，
但这种推荐往往是片面的，比如文献~\cite{bogdanov2011unifying}~\cite{cano2005content}对于对声学特征不敏感但对于情感特征敏感的用户就不适用。
文献~\cite{hyung2012music}对歌曲对应的文本文档进行分析，使用语义特征对歌曲进行刻画，取得了不错的效果。

基于用户即时行为的音乐推荐作为一类比较朴素的推荐算法尽管能够取得不错的推荐效果，但其问题也是显而易见的，即对用户行为的刻画过于简单。

\subsection{基于用户长期行为的音乐推荐}

与基于用户即时行为的音乐推荐不同，基于用户长期行为的音乐推荐对用户收听过的所有歌曲都进行了考察和分析，常见的基于协同过滤的音乐推荐和基于全局特征的音乐推荐都属于
此类。

协同过滤推荐(Collabrative Filtering, CF)是当前最为流行的一类推荐算法，其挖掘用户所处的社会环境，利用群体智能为用户做出推荐。协同过滤推荐基于这样一个假设，
即如果两个用户在过去有相同的行为，那么系统认为他们在未来也会有类似的行为~\cite{sarwar2001item}~\cite{linden2003amazon}~\cite{resnick1994grouplens}。当需要预测一个
用户是否喜欢一个物品时，协同过滤推荐算法首先找到与当前用户喜好类似的用户，进而综合这些相似用户的喜好为用户推荐新的物品。假如用户A收听了《同桌的你》、《睡在我上铺
的兄弟》、《朋友》，用户B收听了《同桌的你》、《朋友》、《白桦林》，用户C收听了《一无所有》、《北京北京》、《太阳》，那么此类算法认为用户A和用户B属于相似用户，
进而将用户B收听但用户A没有收听的歌曲《白桦林》推荐给A。

基于全局特征的音乐推荐是基于用户长期行为推荐算法中比较朴素的一类推荐方法，此类算法认为用户的长期行为能够反映用户对音乐的偏好。因此，在抽取歌曲特征的基础上，此类算
法将用户收听的所有歌曲的平均特征作为用户特征并推荐与此平均特征类似的歌曲给用户。文献~\cite{chordia2008extending} 使用声学特征对歌曲进行刻画，然后计算用户收听
的所有歌曲的平均声学特征并以此作为用户特征。

由于基于用户长期行为的音乐推荐对用户的分析比较全面，因此此类算法往往能够得到比较不错的推荐效果。但是，此类算法对用户所处上下文环境的影响考虑不足，无法满足用户的
即时需求。

\subsection{基于用户中期行为的音乐推荐}

基于用户中期行为的音乐推荐是这样一类推荐算法，它们认为用户在当前会话期内所听歌曲构成的序列能够在一定程度上反映用户所处的上下文环境。因此，它们通过对该歌曲序列的分析
来完成对用户行为的预测和歌曲的推荐。文献~\cite{park2011session}给出了“当前会话期”的定义，即指用户正在收听歌曲的这一段连续时间。文献~\cite{park2011session}使用最
近收听的几首歌曲去匹配用户的收听历史的方法找到类似的收听行为并依据类似行为作出推荐。尽管能够取得一定的效果，但用户所收听的歌曲数目不一，对于历史行为少的用户，
文献~\cite{park2011session}便无能为力。此外，文献~\cite{park2011session}没有对歌曲空间进行降维，而是直接使用歌曲本身去匹配，这降低了算法的可行性。
文献~\cite{hariri2012context}~\cite{mcfee2011natural}是基于用户中期行为音乐推荐的两种典型代表方法，这两种方法首先使用文本分析的方法将歌曲表示成由若干隐含主题构成
的概率分布并使用若干显著主题表征歌曲。这样，它们便将用户在当前会话期内的收听行为建模为主题序列，通过对该主题序列的分析即可预测下一首歌曲可能隶属的主题，进一步地它们
将相关主题中的显著歌曲推荐给用户。其中，文献~\cite{hariri2012context}是使用以PrefixSpan为代表的模式挖掘算法对主题序列进行挖掘的，而文献~\cite{mcfee2011natural}
使用马尔可夫模型对主题序列进行分析。文献~\cite{hariri2012context}~\cite{mcfee2011natural}能够取得较~\cite{park2011session}更好的推荐效果，但是他们只是定性地预测
下一首歌曲可能隶属的隐含主题，无法定量的给出具体的隶属程度。此外，它们只考察了若干显著主题的作用而忽视了其他隐含主题的影响。再者，它们需要依赖其他用户的
行为来为当前用户做出推荐。

为了解决文献~\cite{hariri2012context}~\cite{mcfee2011natural}中存在的问题以较合理地利用用户中期行为提升推荐效果，本文给出一种基于多维时间序列分析的音乐推荐方法，
使用主题模型将歌曲表示成由若干隐含主题构成的概率分布，并在此基础上将用户在当前会话期的行为表示成多维时间序列。通过对该多维时间序列的分析，该方法预测用户可能收听
的下一首歌曲的特征并从曲库中选择类似的歌曲推荐给用户。此外，用户的未来行为除了受到用户中期行为的作用之外还受到用户即时行为和长期行为的影响，但目前未见工作将这三者
的影响综合起来考虑。为此，进一步给出一种基于用户长期、中期和即时行为的综合推荐方法，全面考察用户行为的时间相关性。

\section{相似度度量}

由前文介绍可知，几乎所有的音乐推荐方法都会涉及到相似度的计算，本节将简单介绍几种计算相似度的方法。

\subsection{余弦相似度}

余弦相似度是推荐系统中计算用户与用户或者物品与物品之间相似度的一种常用方法，其通过测量两个向量内积空间夹角的余弦值来度量它们之间的相似性。0度角对应的余弦值是1，
而其他任何角度对应的余弦值都不大于1，并且其最小值是-1。如果两个向量的指向越接近，那么它们内积空间夹角的余弦值越接近于1，即二者越相似。相反，如果两个向量的指向越
相离，那么它们内积空间夹角的余弦值越接近于-1，即二者越不相似。设向量\(\vec {X}_{a}\)和向量\(\vec {X}_{b}\)分别表示用户\emph{a}和用户\emph{b} 的偏好向量，
其中\(\vec {X}_{a}(i)\)表示用户\emph{a}对编号为\emph{i}的物品的偏好值或评分，\(\vec {X}_{b}(i)\)表示用户\emph{b}对编号为\emph{i}的物品的偏好值或评分。那么，
用户\emph{a}和用户\emph{b}的相似度可以按照公式2.1 进行计算，其中\emph{K}表示物品集合中物品的数目。物品之间的余弦相似度可以按照类似的方式进行计算。

\begin{equation}
sim(\emph{a},\emph{b})=cos(\vec {X}_{a},\vec {X}_{b})=\frac{\sum_{i=1}^{K}{\vec {X}_{a}(i)\vec {X}_{b}(i)}}{\sqrt{\sum_{i=1}^{K}{\vec {X}_{a}(i)}^{2}} \\
\sqrt{\sum_{i=1}^{K}{\vec {X}_{b}(i)}^{2}}}\
\end{equation}

\subsection{KL距离}

KL距离也被称为相对熵或KL散度，是两个概率分布\emph{P}和\emph{Q}差别的非对称性的度量，用来度量使用基于\emph{Q} 的编码来编码来自\emph{P} 的样本平均所需的额外的比特
个数~\cite{kullback1951information}。如果能够把物品表示成一个概率分布，那么显然可以用KL距离来衡量两个物品之间的相似度。设\(P=({p}_{1},...,{p}_{i},...,{p}_{K})(1\le{i}\le{K})\)
表示物品\emph{p}对应的概率分布，物品\emph{q}对应的概率分布用\(Q=({q}_{1},...,{q}_{i},...,{q}_{K})\)表示，其中\emph{K}表示随机变量的取值数目。那么，物品\emph{p}
和\emph{q}之间的KL距离可以按照公式2.2进行计算，其取值非负。需要注意的是，KL散度仅当概率分布\emph{P} 和\emph{Q} 各自总和均为1，且对于任何\emph{i}皆满足
\(\emph{p}_{i}>0\) 及\(\emph{q}_{i}>0\)时才有定义，若式中出现0ln0的情况，其值按0处理。

\begin{equation}
{dis}_{KL}(p,q)=\sum_{i=1}^{K}{p}_{i}ln\frac{{p}_{i}}{{q}_{i}}
\end{equation}

由于KL距离是非对称的，即

\begin{equation}
{dis}_{KL}(p,q)\neq{dis}_{KL}(q,p)
\end{equation}

而物品之间的相似度应该满足对称性，即

\begin{equation}
sim(p,q)=sim(q,p)
\end{equation}

因此，不能直接使用KL距离来计算物品之间的相似度，但可以使用\emph{p}到\emph{q}的KL距离与q到p的KL 距离的平均值来作为二者的最终距离，这样就可以满足对称性的要求，
如公式2.5所示。进一步地，可以使用如公式2.6所示的方法计算二者之间的相似度。

\begin{equation}
{dis}_{avgKL}(p,q)=\frac{{{dis}_{KL}(p,q)}+{{dis}_{KL}(q,p)}}{2}
\end{equation}

\begin{equation}
{sim}_{KL}(p,q)=\frac{1}{1+{dis}_{avgKL}(p,q)}
\end{equation}

\subsection{Hellinger距离}

Hellinger距离也是是一种度量两个概率分布之间相似度的方法。与KL距离不同的是，其天然满足对称性，因此可以直接用来计算物品之间的相似度~\cite{oosterhoff2012note}。
物品\emph{p}和物品\emph{q}之间的Hellinger 距离可以按照公式2.7计算，进而可按公式2.8可以计算二者之间的相似度。

\begin{equation}
{dis}_{hellinger}(p,q)=\frac{1}{\sqrt{2}}\sqrt{\sum_{i=1}^{K}({\sqrt{{p}_{i}}-\sqrt{{q}_{i}}})^{2}}
\end{equation}

\begin{equation}
{sim}_{hellinger}(p,q)=\frac{1}{1+{dis}_{hellinger}(p,q)}
\end{equation}

本文所述音乐推荐方法将使用主题模型建模的方法将每一首歌曲表征为由若干隐含主题构成的一个概率分布，因此KL距离和Hellinger距离将被本文用来计算两首歌曲的相似度。

\section{评测指标}

推荐系统所研究的问题主要包括评分预测问题、Top-N推荐问题、冷启动问题、可解释性问题以及用户交互问题等~\cite{adomavicius2005toward}。其中，评分预测问题和Top-N推荐问题
是得到最广泛研究且最为重要的内容。所谓评分预测问题就是根据用户已经产生的评分记录来预测其对尚未评分物品的可能打分，而Top-N推荐是指为用户生成一个包含\emph{N}个符合其偏好的物
品列表。 围绕着这两类问题，研究人员给出了众多推荐算法，本文将简单介绍评测推荐算法优劣的一些指标。

\subsection{用户满意度}

用户作为推荐系统的重要参与者也是推荐系统最终的服务对象，其满意度是评测一个推荐系统优劣的最重要指标。一般来说，用户满意度可以通过对一些用户行为的统计得到。
比如，在电子商务网站中可以通过用户的实际购买情况来评判，或者通过设置“满意”/“不满意”按钮进行显式地统计。更一般的情况是，可以使用点击率、用户停留时间和转化率等指标
度量用户的满意度。对于本文所研究的音乐推荐系统，可以统计用户在系统上的“喜欢”/“不喜欢”或者“收听”/“放弃”等行为来评估不同音乐推荐算法的推荐效果。然而，用户满意度作为真实场
景中的评测指标往往只能通过用户调查或者在线实验的方法获得而无法实现离线计算，这增加了研究人员评估算法优劣的难度。因此，在实际的研究工作中很少通过这个指标来评估不
同推荐算法的优劣。

\subsection{预测准确度}

预测准确度是度量一个推荐系统或者推荐算法预测用户行为能力的重要指标。从推荐系统诞生的那一天起，几乎99\%与推荐系统相关的论文都在讨论这个指标，这主要是因为该项指标
可以通过离线实验计算，方便了研究人员研究推荐算法~\cite{xlvector2012}。对于评分预测问题，一般使用均方根误差(Root Mean Square Error, RMSE)和平均绝对误差
(Mean Absolute Error, MAE)来表征算法的预测准确度~\cite{herlocker2004evaluating}。RMSE可由公式2.9计算得到。

\begin{equation}
RMSE=\sqrt{\frac{\sum_{u,i\in{T}}{({r}_{ui}-{\hat{r}}_{ui})}^{2}}{|T|}}
\end{equation}

其中，\emph{T}代表测试集，\emph{u}和\emph{i}表示测试集中的用户和物品，\({r}_{ui}\)是用户\emph{u}对物品\emph{i}的实际评分，而\({\hat{r}}_{ui}\)是推荐算法给出的预测评分。

MAE采用绝对值计算预测误差，如公式2.10 所示。

\begin{equation}
MAE=\frac{\sum_{u,i\in{T}}|{r}_{ui}-\hat{{r}_{ui}}|}{|T|}
\end{equation}

预测误差越小，预测准确度越高，推荐算法的效果越好。

Top-N推荐一般通过准确率(precision)和召回率(recall)来度量算法的优劣。设\(R(u)\)是根据用户在训练集上的行为给用户作出的推荐列表，而\(T(u)\)是用户在测试集上的行为列
表~\cite{powers2011evaluation}。 那么，推荐结果的准确率和召回率如公式2.11和2.12所示。命中率和准确率越大，预测准确度越高，推荐算法的效果越好。

\begin{equation}
Precision=\frac{\sum_{u\in{U}|R(u)\cap{T(u)}|}}{\sum_{u\in{U}}|R(u)|}
\end{equation}

\begin{equation}
Recall=\frac{\sum_{u\in{U}|R(u)\cap{T(u)}|}}{\sum_{u\in{U}}|T(u)|}
\end{equation}

\subsection{其他评测指标}

除了预测准确度这一重要指标之外，推荐系统的评测还有诸如覆盖率、多样性等指标，这些指标从不同的角度看待推荐的有效性。其中，覆盖率(Coverage)描述的是一个推荐系统对物品
长尾的发掘能力，可以简单地定义为推荐系统能够推荐出来的物品占总物品集合的比例。覆盖率越大，说明系统所能推荐的物品越广泛，也说明系统挖掘物品长尾的能力越强。
多样性(Diversity)用来描述推荐列表中物品两两之间的不相似性，列表中物品两两之间的相似性越小表示推荐的多样性越大。

考虑到用户满意度无法进行离线实验而覆盖率、多样性等对推荐算法的表征能力不佳，本文主要使用预测准确度来评估所给出的音乐推荐方法。

\section{分布式实时计算系统}

尽管目前单机的处理能力已经得到了极大提升，但其在应对大数据时代产生的海量数据时仍然非常吃力。为了解决大数据时代海量数据的处理和分析的问题，Google 提出了一种分布
式计算模型，即MapReduce，该模型使得由一般能力机器组成的集群可以完成大规模或者超大规模的计算工作。在Google 工作的启发下，Apache于2005年开发了
分布式应计算框架Hadoop~\cite{Hadoop}。Hadoop对于批处理的工作以及离线的海量数据分析比较有优势，但其在面对一些实时性要求比较高的计算任务时，处理能力略显欠缺。
为了弥补这一缺憾，以Storm~\cite{Storm}为代表的分布式实时计算系统被开发了出来，这些系统及框架在实时数据流分析方面能够取得比Hadoop更好的效率和效果。
其中，Storm是由Twitter 开发的一款开源的分布式实时计算框架，其适用于流数据处理和分布式远程过程调用两种场景。对于流数据处理场景，Storm可以用来处理源源不断流进
来的消息，处理之后将结果写入到某个存储中去。此外，Storm的处理组件是分布式的且处理延迟极低，使得其在分布式远程过程调用的场景中也能够得到比较充分的应用。

本文所要解决的问题恰恰是一个实时数据流的分析问题，因此本文后面将会选用Storm 进行数据的分析和处理，本节对其基本组成及其在分布式远程过程调用中的应用进行介绍。

\subsection{基本组成}

一个Storm集群往往是由一个主控节点(Master Node)和多个工作节点(Work Nodes)组成。其中，主控节点上运行着一个名为“Nimbus” 的守护进程，用于分配代码、布置任务及故
障检测，而每个工作节点都运行一个名为“Supervisor”的守护进程，用于监听工作、开始及终止工作进程。Nimbus和Supervisor都能快速失败，而且是无状态的，这样一来它们就变得
十分健壮，而两者的协调工作是由Apache ZooKeeper来完成的。

在Storm中，一个实时应用的计算任务被打包成一个Topology任务发布，且Topology任务一旦提交后永远不会结束，除非用户显式地去停止任务。计算任务Topology是由多个
Spout和Bolt计算组件构成，这些计算组件是通过数据流连接起来的。其中，Spout是Storm中的消息源，用于生产消息，Bolt是Storm中的消息处理者，
用于消息的处理。Topology中每一个计算组件都有一个并行执行度，在创建Topology时可以进行指定，Storm会在集群内分配对
应并行度个数的线程来同时执行这一组件。图2.1是Twitter Storm官方给出的一个典型Topology示意图，其中水龙头表示用以生产数据的Spout组件，闪电表示用户处理数据Bolt
组件，消息或数据由Spout组件产生后便在不同的Bolt组件中进行流动并被处理。Storm的编程非常简单，用户只需要在Spout组件中实现数据读取及分割的逻辑，在Bolt组件中实现数据
的处理逻辑，同时在各组件中指定数据流动方式即可轻松地完成并发布一个实时计算的任务。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/storm.eps}
\caption{典型Twitter Storm示意图}
\label{fig_storm}
\end{center}
\end{figure}

\subsection{分布式过程调用}

分布式远程过程调用（Distributed Remote Procedure Call，DRPC）是联系客户端与Storm集群的一种机制，Storm中引入这一机制的主要目的是利用Storm的实时计算能力来并行化
CPU 密集型计算。Storm集群上运行的拓扑接收调用函数的参数信息作为输入流，并将计算结果作为输出流发射出去。其中，DRPC通过是DRPC Server 实现的，其整体工作过程如下：

\begin{enumerate}
\item 接收到一个RPC调用请求；

\item 发送请求到Storm上的拓扑；

\item 从Storm上接收计算结果；

\item 将计算结果返回给客户端。
\end{enumerate}

图2.2更为细致地描述了DRPC的工作流程，大致可以分为如下五个步骤：

\begin{enumerate}
\item Client向DRPC Server发送被调用执行的DRPC函数名称及参数；

\item Storm上的Topology通过DRPCSpout实现这一函数，从DPRC Server接收到函数调用流；

\item DRPC Server会为每次函数调用生成唯一的id；

\item Storm上运行的Topology开始计算结果，最后通过一个ReturnResults的Bolt连接到DRPC Server，发送指定id的计算结果；

\item DRPC Server通过使用之前为每个函数调用生成的id，将结果关联到对应的发起调用的Client，将计算结果返回给Client。
\end{enumerate}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.6\textwidth]{figures/drpc.eps}
\caption{DRPC工作流程示意图}
\label{fig_drpc}
\end{center}
\end{figure}

\section{文本建模}

为了对歌曲进行全面地刻画，本文将使用文本分析的方法对歌曲进行建模，本节介绍一些常用的文本建模方法。

\subsection{向量空间模型}

计算机不具备人脑的结构，无法理解自然语言，所以需要首先将无结构的自然语言文本转化为计算机可计算的特征文本。为此，Salton等人在20世纪70年代提出了向量空间模型
(Vector Space Model, VSM)~\cite{salton1975vector}。向量空间模型首先将每一个文档看做一个词袋(Bag of Words)，即认为一篇文档是由一组词构成的一个集合且词与词之
间没有顺序以及先后的关系。其次，向量空间模型将文档表示成一个向量，向量的每一维表示一个词项，而每一维的取值表示该词项在文档中的权重。对于文档集合\emph{D}中
编号为\emph{j}的文档\({d}_{j}\)，可以将之表示成一个\emph{t}维的向量\(\vec {{d}_{j}}=({\omega}_{1,j},...,{\omega}_{t,j})\)，其中\emph{t}表示词项的数目，
\({\omega}_{i,j}(1\leq{i}\leq{t})\) 表示第\emph{i}个词项在文档\({d}_{j}\)中的权重。在对文本进行建模的过程中，词的选取及权重的计算有以下几种典型方式：

\begin{enumerate}
\item 布尔模型。这是最为简单直观的一种计算词项权重的方法，其将词项在文档中是否出现作为其权重，如果词项在文档中出现那么将其权重记为1，否则记为0。虽然这种方法比较
简单，但是它没有体现词语在文档中出现的频率。一般来讲，词语在文档中出现的越多，说明它对该篇文档的重要性越大（“的”、“得”、“地”、“是”等停用词除外）。

\item 词频模型。与布尔模型不同的是，词频(Term Frequency, TF)模型统计词项在文档中出现的次数，然后得到词项的频率，并将之作为词项的权重。词项\({t}_{i}\)相对于
文档\({d}_{j}\)的词频如式2.13所示。

    \begin{equation}
    {tf}_{i,j}=\frac{{n}_{i,j}}{\sum_{k}{n}_{k,j}}
    \end{equation}

    这里,\({n}_{i,j}\)表示该词项在该文档中出现的次数。词频模型突出了词频对词项重要性的影响，能够取得比布尔模型较好的效果。但是，词语的重要性不仅随着它在文档中
    出现的次数成正比增加，而且可能会随着它在语料库中出现的频率成反比下降。

\item 词频-逆文本频率模型。词频-逆文本频率(Term Frequency - Inverse Document Frequency，TF-IDF)是对TF模型的补充，其认为词项的重要性随着其在特定文档中出现次数
的增加而增强，但同时随着其在全体文本中出现次数的增加而减弱，即该模型认为对区别文档最有意义的词语应该是那些在文档中出现频率高、而在整个语料库中的其他文档中出现
频率少的词语。词项\({t}_{i}\)相对于文档\({d}_{j}\)的TF-IDF取值如式2.14所示。

    \begin{equation}
    {tfidf}_{i,j}={tf}_{i,j}\times{{idf}_{i}}
    \end{equation}

    \({idf}_{i}\)为逆向文本频率，定义如式2.15所示。

    \begin{equation}
    {idf}_{i}=log\frac{|D|}{|\{j:{t}_{i}\in{{d}_{j}}\}|}
    \end{equation}

    其中，\(|D|\)表示文档集合中的文档总数，\(|\{j:{t}_{i}\in{{d}_{j}}\}|\)表示文档集合中包含词项\({t}_{i}\)的文档数目。TF-IDF 结构简单，容易理解，被广泛应用。
    但是，其无法准确捕捉文档内部与文档间的统计特征，也不能解决同义词和多义词的问题，因此精确度不是很高。
\end{enumerate}

\subsection{隐含狄利克雷模型}

为了解决同义词和多义词的问题，Blei等人于2003年提出了隐含狄利克雷分配模型(Latent Dirichlet Allocation，LDA)~\cite{blei2003latent}~\cite{hoffman2010online}。
LDA也是一种典型的词袋模型，其认为一篇文档由多个主题构成，而文档中每一个词都是由对应的主题生成而来。其中，主题表示一个概念、一个方面，表现为一系列相关的单词，
是这些单词的条件概率。形象来说，主题就是一个桶，里面装了出现概率较高的单词而这些单词与这个主题有很强的相关性。这样，LDA模型便通过隐含主题将文本与词项联系起来，
从而达到降维的目的。LDA是一种生成模型，一篇文档按照如下所示的规则生成：

\begin{enumerate}
\item 假设有两种类型的桶，一种是文档-主题桶，桶里的每一个球代表一个主题；另一种桶是主题-词汇桶，桶中的每一个球代表一个词汇。

\item 文档的生成过程就是不断从桶中取球的过程，每一次先从文档-主题桶中取出球，得到该球代表的主题编号\emph{z}。

\item 从编号为\emph{z}的主题-词汇桶中取球，得到一个词汇。

\item 不断重复2,3两步，即可生成一篇文档。
\end{enumerate}

在LDA模型中，记文档-主题的概率分布为多项式分布\(\vec{\theta}\)，主题-词汇的概率分布为多项式分布\(\vec{\varphi}\)。LDA模型认为\(\vec{\theta}\)和\(\vec{\varphi}\)
是模型中的参数，而考虑到参数都是多项式分布，模型选择狄利克雷分布作为其先验分布。在确定了这些分布之后，LDA下面需要做的就是估计这些分布的参数，如算法1所示的
吉布斯采样(Gibbs Sampling)是目前比较流行的估计参数的方法。

\begin{algorithm}
\caption{LDA模型的Gibbs采样算法}
\label{alg:gibbssampling}
\begin{algorithmic}[1]
\STATE 首先对所有文档中的所有词遍历一遍，为其都随机分配一个主题，即\({z}_{m,n}=k\sim{Mult(1/K)}\) ，其中\emph{m}表示第\emph{m}篇文档，\emph{n}表示文档中的
第\emph{n} 个词，\emph{k}表示主题，\emph{K}表示主题的总数，之后将\({{n}^{k}}_{m}\)、\({n}_{m}\)、\({{n}^{t}}_{k}\)、\({n}_{k}\)都加1, 它们分别表示在第\emph{m}
篇文档中主题\emph{k}出现的次数、第\emph{m} 篇文档中主题数量的和、主题\emph{k}对应的词\emph{t} 的次数，\emph{k}主题对应的总词数。

\STATE 对第1篇文档中的所有词进行遍历，假如当前文档中的词\emph{t}对应主题为\emph{k}，则将\({{n}^{k}}_{m}\)、\({n}_{m}\)、\({{n}^{t}}_{k}\)、\({n}_{k}\)都减1,
即先拿出当前词，之后根据式2.16取样出新的主题，再将\({{n}^{k}}_{m}\)、\({n}_{m}\)、\({{n}^{t}}_{k}\)、\({n}_{k}\)都加1。其中，\(\alpha\)
和\(\beta\)为对应的Dirichlet分布的参数，\emph{V}为词汇总数。

\begin{equation}
p({z}_{i}=k|{z}_{-i},w)\propto{\frac{({{n}^{t}}_{k,-i}+{\beta}_{t})({{n}^{k}}_{m,-i}+{\alpha}_{k})}{\sum_{t=1}^{V}({{n}^{t}}_{k,-i}+{\beta}_{t})}}
\end{equation}

\STATE 重复步骤2直至遍历所有文档。

\STATE 输出LDA模型中的参数\(\vec{\theta}\)和\(\vec{\varphi}\)。

\begin{equation}
{\theta}_{m,k}=\frac{{{n}^{k}}_{m}+{\alpha}_{k}}{{n}_{m}+{\alpha}_{k}}
\end{equation}

\begin{equation}
{\varphi}_{k,t}=\frac{{{n}^{t}}_{k}+{\beta}_{t}}{{n}_{k}+{\beta}_{t}}
\end{equation}

\end{algorithmic}
\end{algorithm}

在本文后续实验中，我们将分别以TF-IDF为代表的向量空间模型和以LDA为代表的主题模型对歌曲对应的文档进行建模，发现LDA能够获得较高的推荐准确率，因此我们将LDA作为我们
主要的文本建模方法。

\section{时间序列预测}

歌曲时间短、消费代价低的特点决定了其能够较容易地形成序列，且这种序列是有严格的时间顺序的。本文将通过对用户在当前会话期内所听歌曲形成的时间序列的分析来预测用户
接下来的行为。本节将简单介绍一些常用的时间序列预测方法。

\subsection{简单平均法}

简单平均法是以观察期内时间序列的各期数据（观察变量）的平均数作为下期预测值，按照采用的平均方法又可以分为算术平均法、加权平均法和几何平均法三类。其中，算术平均法
以观察变量的算术平均数作为下期预测值，加权平均法以观察变量的加权算术平均数作为下期的预测值，而几何平均法是以观察变量的几何平均数作为下期的预测值。简单平均法比较
简单、直观，但其预测误差一般偏高。

\subsection{指数平滑法}

指数平滑法是由移动平均法改进而来的，是一种特殊的加权移动平均法。这种方法既有移动平均法的长处，又可以减少历史数据的数量。一方面，它把过去的数据全部加以利用。另一方面，
它利用平滑系数加以区分 ，使得近期数据比远期数据对预测值影响更大。它特别适合用于观察值有有长期趋势和季节变动，必须经常预测的情况。按照平滑的次数可以可分为一次指数
平滑法和多次指数平滑法。其中，一次平滑法是计算时间序列的一次指数平滑值，以当前观察期的一次指数平滑值为基础，确定下期预测值。与二次移动平均法类似，二次指数平滑法
就是对时间序列的一次指数平滑值再次进行指数平滑。

\subsection{差分整合移动平均自回归模型}

差分整合移动平均自回归模型(Autoregressive Integrated Moving Average model,ARIMA)又称为Box-Jenkins方法，是由Box和Jenkins于1970年提出的一种时间序列预测方法，
目前已经得到广泛的应用~\cite{makridakis1997arma}。

在模型ARIMA(p,d,q)中，“AR”表示自回归模型，\emph{p}为自回归阶数；“MA” 表示滑动平均模型，\emph{q}表示滑动平均的阶数；\emph{d}表示将时间序列转化为平稳时间序列所作的差分次数，
即差分阶数。ARIMA首先需要进行\emph{d}次差分从而将非平稳序列转化为平稳序列，然后利用自回归模型和滑动平均模型对转换后的平稳序列进行预测。进一步地，模型ARIMA(p,d,q)
可以表示成如下三个式子。

\begin{equation}
\Phi(B){(1-B)}^{d}{y}_{t}=\delta+\Theta(B){\varepsilon}_{t}
\end{equation}

\begin{equation}
\Phi(B)=1-\sum_{i=1}^{p}{\varphi}_{i}{B}^{i}
\end{equation}

\begin{equation}
\Theta(B)=1+\sum_{i=1}^{q}{\theta}_{i}{B}^{i}
\end{equation}

其中,\({y}_{t}\)为时间序列Y的第t个取值，B是滞后算子，\(\theta\)和\(\varphi\)为模型参数。

ARIMA的执行流程主要分为模型识别(Model Identification)、参数估计(Parameter Estimation)和诊断检测(Diagnostic Checking)三个阶段。其中，模型识别阶段主要完成检测序列
是否平稳的工作。如果序列不平稳，那么需要通过差分的方法将序列转化为平稳序列并给出差分阶数\emph{d}。在此基础上，识别出序列适用的可能模型，如自回归模型或滑动平均模型
或者二者的混合。而参数估计阶段主要完成模型参数的估计工作，即通过最小二乘法估计参数\(\theta\)和\(\varphi\)。 诊断检测阶段用以检测所给出的模型及参数是否符合条件，
如果符合则选用此模型进行预测，否则重新识别模型。

ARIMA模型已经在计量经济学中得到了非常广泛地应用而且也取得了比较理想的预测效果，因此本文后续的工作中将使用该模型完成对用户行为序列的分析和预测工作。

\chapter{基于多维时间序列分析的音乐推荐方法}
\label{C:mtsa}

本章将给出一种基于多维时间序列分析的音乐推荐方法，该方法实现了对用户听歌行为定量且全面地分析和预测，同时减少了对其他用户行为的依赖，使得推荐的结果更加符合用户即时
偏好。首先，该方法使用用户给歌曲所打的标签构造歌曲对应的文档，进而通过主题模型的方法对文档集合进行建模并最终把每一首歌曲都表示成由若干隐含主题构成的一个概率分布。
在此基础上，该方法将用户在当前会话期内的听歌行为建模为一个多维时间序列，并通过对该多维时间序列的分析来预测用户行为，而这样做的原因是该方法认为用户在当前会话期内所
收听的歌曲序列能够在一定程度上表征其所处的上下文环境。

我们将在本章中对该方法进行详细地阐述。首先，我们将介绍本文工作所研究问题的相关描述和定义。然后，我们给出该方法的工作流程，包括隐含主题的抽取、多维时间序列的构造
及分析预测、最终推荐结果的生成等内容。最后，我们介绍为验证该方法有效性而设计的实验及实验结果。

\section{问题描述}

音乐推荐的目的在于通过对音乐本身属性和用户行为习惯的分析，帮助用户过滤掉不必要的信息，并最终为用户推荐符合其喜好的音乐作品。换句话来说，就是解决如何在已知歌曲特征以及用户之前所收听歌曲的情况下准确地预测用户可能收听的下一首歌曲的问题~\cite{park2011session}，如图3.1所示。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/nextsong.eps}
\caption{下一首歌预测问题的说明图}
\label{fig_nextsong}
\end{center}
\end{figure}

为了更好地描述本文所要研究的问题，我们首先定义用户集和歌曲集，如下所示：

\textbf{用户集\emph{U}}：所有用户的集合，如式3.1所示。其中，\emph{v}表示用户的数目，即\(v=|U|\)。

\begin{equation}
U=\{{u}_{1},{u}_{2},...,{u}_{v}\}
\end{equation}

\textbf{歌曲集\emph{S}}：所有可以推荐给用户的物品(这里就是歌曲，本文不加区分地使用“歌曲”和“物品”)的集合，如式3.2所示。其中，\emph{m}表示曲库中歌曲的数目，
即\(m=|S|\)。为方便起见，我们认为用户收听的歌曲一定在歌曲集合中。

\begin{equation}
S=\{{s}_{1},{s}_{2},...,{s}_{m}\}
\end{equation}

对于用户集\emph{U}中给定的一个用户\emph{u}，本文所要研究的音乐推荐系统的目标就是为该用户推荐其可能喜欢的下一首歌曲。为了衡量用户对歌曲的喜欢程度，我们定义如下
所示的效用函数：

\textbf{效用函数\(utility(u,s)\)}: 表征歌曲\emph{s}对用户\emph{u}的推荐度(如歌曲\emph{s}符合用户\emph{u}喜好的程度、歌曲\emph{s}与系统所预测歌曲的相似度等)。
效用函数反映了用户对某首歌曲的喜爱程度，其值越大表明喜欢程度越大。

如前所述，本文所给的方法是建立在隐含主题分类和用户在当前会话期内听歌序列的基础上，因此我们进一步地定义歌曲对应的隐含主题集合以及用户所收听歌曲对应的序列。

\textbf{主题集\emph{T}}: 由所有隐含主题组成的集合，如式式3.3所示，其中\emph{K}为隐含主题的数目。

\begin{equation}
T=\{{t}_{1},{t}_{2},...,{t}_{K}\}
\end{equation}

\textbf{事件\(e(u,\tau,s)\)}: 表示用户\emph{u}在时刻\(\tau\)收听了歌曲\emph{s}。显然，歌曲\emph{s}可由用户\emph{u} 和时刻\(\tau\)唯一决定，因此\(e(u,\tau,s)\)可
简化为\(e(u,\tau)\)。

\textbf{序列\emph{Q(u)}}: 用户\emph{u}在给定平台下的所有听歌事件按照时间顺序排列开来得到的序列，如式3.4所示。

\begin{equation}
Q(u)=<e(u,{\tau}_{1}),e(u,{\tau}_{2}),...,e(u,{\tau}_{\pi}),e(u,{\tau}_{\pi+1}),...,e(u,{\tau}_{\pi+n})>
\end{equation}

其中，\(\pi+n\)为用户\emph{u}所收听或喜欢的歌曲数目，\(\tau\)为事件发生的时间，且\({\tau}_{1}<{\tau}_{2}<...<{\tau}_{\pi}<{\tau}_{\pi+1}<...<{\tau}_{\pi+n}\)，
即用户收听这\(\pi+n\)首歌曲是按照一定的次序一首接一首收听的。另外，\emph{Q(u)}中最后\emph{n}个事件是用户在当前会话期内产生的，即从事件\(e(u,{\tau}_{\pi+1})\)到
事件\(e(u,{\tau}_{\pi+n})\)之间对应的\emph{n}首歌曲是用户当前连续收听的，而序列中的最后一个事件\(e(u,{\tau}_{\pi+n})\)是正在发生的。也就是说，这\emph{n}个听歌事
件两两之间没有明显的时间间隔，而事件\(e(u,{\tau}_{\pi+1})\)和事件\(e(u,{\tau}_{\pi})\)之间有明显的时间间隔，如式3.5 和3.6所示。

\begin{equation}
|{\tau}_{\pi+i}-{\tau}_{\pi+i-1}|\le\varepsilon(1<i\le{n})
\end{equation}

\begin{equation}
|{\tau}_{\pi+1}-{\tau}_{\pi}|>\varepsilon
\end{equation}

其中，\(\varepsilon\)是给定的时间间隔，用以分割不同的听歌会话，在后文的实验中我们将之设为8分钟，而在系统实现中将之设为2小时。为了方便，我们只考察在给定平台下确实
有听歌行为的用户，即用户在给定平台下确实有听歌事件且其当前正在该平台下收听歌曲。而对于在给定平台下没有任何听歌行为以及当前不在该平台下听歌的用户，为他们进行推荐
比较困难，这是整个推荐系统领域重点研究的冷启动问题，本文对此不做深究。

\textbf{目标歌曲}: 符合用户喜好或者用户接下来可能收听的歌曲。

由之前的分析可知，本文所提方法的本质输入是歌曲对应的隐含主题\emph{T}和用户\emph{u}在当前会话期内的收听序列\(Q(u)[\pi+1:\pi+n]\)，而最终目标是为用户推荐其最可能收听的
下一首歌曲。也就是说，在已知主题集\emph{T}和用户\emph{u}当前会话期收听序列\(Q(u)[\pi+1:\pi+n]\)的情况下从歌曲集\emph{S}中找出那些对用户的效用函数取值最大的目标歌曲
\emph{N(u)}并推荐给用户，如式3.7所示。

\begin{equation}
N(u)={\arg\max}_{s\in{S}}\emph{utility(u,s)}
\end{equation}

为了解决预测用户可能收听的下一首歌曲的问题，有两个难点需要解决：

\begin{enumerate}
\item 如何全面完整地对歌曲进行刻画。

\item 如何对用户的行为序列进行分析以预测用户行为。
\end{enumerate}

\section{方法框架}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.9\textwidth]{figures/framework.eps}
\caption{基于多维时序分析的音乐推荐方法的工作流程示意图}
\label{fig_framework}
\end{center}
\end{figure}

针对上文所定义的音乐推荐问题，本文提出一种基于多维时间序列分析的音乐推荐方法，该方法按如图3.2 所示的流程工作。其中，虚线箭头表示离线处理模块，主要用来对歌曲进行
刻画，即解决难点1；实线箭头表示在线处理模块，主要用来对用户的行为序列进行分析进而预测用户未来的可能行为，即解决难点2。

在离线模块中，我们首先定期从音乐网站上抓取以用户标签为主的歌曲文本信息，然后将这些标签信息按照一定的方式组合成文档，那么这些文档构成的文档集合将和歌曲集\emph{S}一
一对应。关于文档的构造方式，本文采用的方法是将被标记到给定歌曲的标签按照其被标记的次数在给定歌曲对应的文档中重复若干次。假设给定歌曲\emph{s}所具有的标签信息可以表示为一
个标签集合，比如\(TagSet(s)\)=\{\(\textless\)“rock”，5\(\textgreater\)，\(\textless\)“pop”，3\(\textgreater\)，\(\textless\)“male”，2\(\textgreater\)\}，那么其对应的文档可以表示为\(Doc(s)\)=“rock rock rock rock rock pop pop pop male male”。其中，
标签“rock” 在\(Doc(s)\)中出现5 次，标签“pop” 在\(Doc(s)\)中出现3次,标签“male”在文档\(Doc(s)\)中出现2次。由于主题模型将文档看做一个词袋模型，因此“rock”、“pop”、
“male”在文档中出现的顺序不影响建模结果。在获得歌曲集对于的文档集之后，我们对该文档集进行主题模型建模，从而抽取出歌曲中包含的隐含主题。这样，每一首歌曲可以用
一个主题权重向量表示，向量中的每一维取值表征对应主题对歌曲内容的贡献程度。

在在线处理模块中，我们首先获取用户在当前会话期内所听的歌曲，然后将这些歌曲按照时间先后顺序排列开来得到用户的当前会话序列。在此基础上并结合离线模块的处理结果，
我们将用户的当前会话序列建模为一个多维时间序列。进一步地，我们使用一些经典有效的时间序列预测方法对该多维时间序列的每一个分量进行分析并预测单变量时间序列的
下期取值。然后，我们将这些单变量时间序列的预测值组合起来构成目标歌曲对应的主题权重向量。得到目标概率分布之后，我们计算曲库中所有歌曲与目标歌曲之间的相似度并
按照相似度由大到小排列。最后，我们选取排位靠前的\emph{N}首歌曲作为推荐列表推荐给用户。在下面的章节中,我们将对方法工作流程中的主要步骤进行一一介绍，包括如何进行主
题模型建模、为何选择多维时间序列作为用户行为序列的模型以及相似度计算、最终推荐列表生成等。

\section{主题模型建模}

如前所述，为了全面地刻画歌曲，本文在将歌曲映射成一个个文档的基础上通过主题模型建模来对歌曲进行描述。隐含狄利克雷分配(Latent Dirichlet Allocation,LDA)
模型~\cite{blei2003latent} 是当前最具代表性也是最流行的概率主题模型，已经在文本挖掘、信息处理、多文档摘要等领域得到了广泛的应用~\cite{rosen2004author}
~\cite{tang2009multi}。LDA模型能够将文档映射到由若干隐含主题构成的概率分布，而这个分布可以用一个主题权重向量表示，向量的每一维表征了对应主题对文档内容的贡献程度。通过LDA 主题模
型建模，我们不但可以抽象出文档中包含的隐含主题集合\emph{T}，而且能够以量化的方式表达不同文档之间的距离和相似度。本节详细介绍利用LDA主题模型对歌曲建模的过程。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/squares.eps}
\caption{Last.fm中歌曲Squares的标签云}
\label{fig_squares}
\end{center}
\end{figure}

首先，我们从Lastfm(http://last.fm)、豆瓣(www.douban.com)等音乐网站上抓取用户对歌曲所标注的标签,这些标签对歌曲内容的描述比较全面，既包含了歌曲的名称、曲作者信息、
专辑信息、发行年代等基本信息，还包含了歌曲所表达主题、歌曲类型、用户心情、适合场合等扩展信息。以The Beta Band 的Squares 为例，用户为其标注的标签有表征年代
的“2002”/“2000s”、表征类型的“indie rock”/“folk pop”、表征用户感受的“beautiful”/“want” 等，如图3.3所示。在得到歌曲对应的标签信息后，我们将这些标签按照一定的方式进
行组织，从而生成歌曲对应的文本文档。为了减少噪音，我们只利用那些被多数人使用的标签来完成歌曲对应文本文档的构造，具体来说我们只考虑被标记次数大于10的标签。这样，
每一首歌曲\emph{s}都将对应一篇文档\emph{d}，而歌曲集\emph{S}将对应到一个文档集\emph{D}。最后，我们对文档集\emph{D} 进行LDA主题模型建模，从而得到包含\emph{K}个用来
全面刻画歌曲特征的隐含主题集合T。同时，对于歌曲集\emph{S}中的任意歌曲\emph{s}，我们能够得到其对应的隐含主题权重向量，如式3.8所示。

\begin{equation}
\vec{s}=({\omega}_{1},{\omega}_{2},...,{\omega}_{i},...,{\omega}_{K})(1\le{i}\le{K})
\end{equation}

其中，\({\omega}_{i}=0\)表示歌曲完全不属于该隐含主题代表的类别，即该隐含主题对歌曲的内容完全没有贡献；\({\omega}_{i}=1\)表示歌曲完全属于该隐含主题代表的类别；
\(0<{\omega}_{i}<1\)表示歌曲在一定程度上隶属于该隐含主题代表的类别。

表3.1展现了歌曲Squares的若干显著主题及其隶属于这些主题的概率。由表3.1可以看出，歌曲Squares隶属于主题508的概率为0.215，这说明主题508对该歌曲贡献度为0.215。类似的，
主题313对歌曲的贡献度为0.186，主题231对该歌曲的贡献度为0.072。由于主题508对文档的贡献度大于其他隐含主题，因此我们认为歌曲能够以更大的概率划分到主题508 中。如前所述,
我们不去也无法准确地描述这些主题具体是什么含义，而我们正是利用这一点来回避确定性分类带来的弊端。

\begin{table}[!hbp]
\caption{歌曲Squares的显著主题及隶属度}
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
主题id & 508 & 313 & 296 & 106 & 231 \\
\hline
隶属度 & 0.215 & 0.186 & 0.134 & 0.084 & 0.072 \\
\hline
\end{tabular}
\end{table}

更形象地，我们使用雷达图来表示歌曲在各个隐含主题上的隶属程度。假设隐含主题的数目为4且编号依次为\#1、\#2、\#3、\#4，那么主题向量\(\vec{s}=(0.15,0.25,0.15,0.45)\)
代表的歌曲的雷达图如图3.4所示。其中，雷达图的每个顶点代表一个隐含主题，中心点到各个顶点的距离表示歌曲在该顶点对应隐含主题上的隶属度。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.4\textwidth]{figures/singleradar.eps}
\caption{歌曲的雷达图表示}
\label{fig_singleradar}
\end{center}
\end{figure}

\section{多维时间序列构造与预测}

传统的基于“最相似”假设的推荐方法只考虑用户当前的收听习惯，较少考虑用户行为的序列性趋势，而本文所提出的基于多维时间序列分析的音乐推荐方法则对此进行了考虑。
在通过LDA主题模型对歌曲进行建模而得到歌曲对应的主题权重向量后，我们需要做的就是获取用户在当前会话期内收听的歌曲构成的序列并构造其对应的多维时间序列，然后使用
相应的时间序列分析方法进行预测。

对于上文中给出的一共收听了\emph{n}首歌曲且在当前会话期内收听了\(\pi+n\)首歌曲的用户\emph{u}来说，为了预测其可能收听的下一首歌曲，我们需要获取该歌曲对应的主题权
重向量，如式3.9所示。

\begin{equation}
{\vec{s}}_{\pi+n+1}=({\omega}_{1}(\pi+n+1),{\omega}_{2}(\pi+n+1),...,{\omega}_{i}(\pi+n+1),...,{\omega}_{K}(\pi+n+1))
\end{equation}

其中，\({\omega}_{i}(j)\)表示第\emph{j}首歌曲隶属于第\emph{i}个隐含主题的概率\((1\le{i}\le{K})\)。直接得到这样一个主题向量往往是不太容易的，但估计出该向量对应的
每一维的取值是可行的。因此，要得到下一首歌曲对应的主题向量，我们需要先估计出对应的主题权重向量中每一维的值，然后将这些中间估计值组合起来即可构成完整的估计主
题向量，从而能够在歌曲集\emph{S}中找到最匹配的歌曲推荐给用户。

由前文可知，用户\emph{u}的听歌行为是有时间顺序的。如果我们将用户在某一时间点收听的歌曲对应的主题向量看做变量，那么将此变量在不同时间点的取值按照时间顺序依次排
开即可得到如式3.10所示的多维时间序列~\cite{hamilton1994time}。

\begin{equation}
<{{\vec{s}}_{\pi+1}}^\top,{{\vec{s}}_{\pi+2}}^\top,...,{{\vec{s}}_{\pi+n}}^\top>
\end{equation}

进一步地，将上式在\emph{K}维隐含主题向量上展开，得到如式3.11所示的更为直观的多维时间序列。

\begin{equation}
\begin{split}
TS(u)=< \\
&{({\omega}_{1}(\pi+1),{\omega}_{2}(\pi+1),...,{\omega}_{i}(\pi+1),...,{\omega}_{K}(\pi+1))}^\top, \\
&{({\omega}_{1}(\pi+2),{\omega}_{2}(\pi+2),...,{\omega}_{i}(\pi+2),...,{\omega}_{K}(\pi+2))}^\top, \\
&..., \\
&{({\omega}_{1}(\pi+j),{\omega}_{2}(\pi+j),...,{\omega}_{i}(\pi+j),...,{\omega}_{K}(\pi+j))}^\top, \\
&..., \\
&{({\omega}_{1}(\pi+n),{\omega}_{2}(\pi+n),...,{\omega}_{i}(\pi+n),...,{\omega}_{K}(\pi+n))}^\top, \\
&>
\end{split}
\end{equation}

其中,\(i(1\le{i}\le{K})\)表示隐含主题的编号，\(j(1\le{j}\le{n})\)表示用户在当前会话期内所收听第\emph{j}首歌曲的索引。显然，该多维时间序列中任意一个时间点都对应
着一个\emph{K}维主题向量且对于\emph{K}维主题向量中的每一维来说又对应着一个单变量的时间序列，如式3.12所示。

\begin{equation}
TS(u,i)=<{\omega}_{i}(\pi+1),{\omega}_{i}(\pi+2),...,{\omega}_{i}(\pi+j),...,{\omega}_{i}(\pi+n)>
\end{equation}

其中，\({\omega}_{i}(\pi+j)\)的含义如前所述。通过对\(TS(u,i)\)的分析可以得到用户在当前会话期内所收听的歌曲在编号为\emph{i}的隐含主题上的变化情况，进而可以预测出用户可能
收听的下一首歌曲在编号为\emph{i}的隐含主题上的隶属度，即\({\hat{\omega}}_{i}(\pi+n+1)\)。 进一步地，我们可以获得用户行为在其他隐含主题上的变化情况并估计出用户可能收听的
下一首歌曲在其他隐含主题上的隶属度。通过对\emph{K}个估计值的组合，可以得到如式3.13所示的目标主题向量，即用户可能收听的下一首歌曲的估计主题向量。

\begin{equation}
{\hat{\vec{s}}}_{\pi+n+1}=({\hat{\omega}}_{1}(\pi+n+1),{\hat{\omega}}_{2}(\pi+n+1),...,{\hat{\omega}}_{i}(\pi+n+1),...,{\hat{\omega}}_{K}(\pi+n+1))
\end{equation}

\section{相似度计算}

通过隐含狄利克雷主题建模我们得到了如式3.8所示歌曲集\emph{S}中歌曲对应的主题权重向量，考虑到向量中每一维度的值表征歌曲隶属于某一隐含主题的概率，我们将这些主题权重向量看作
是离散的概率分布。进一步地，通过对多维时间序列的分析和预测，我们得到了如式3.13所示用户\emph{u}可能收听的下一首歌曲对应的主题权重向量的估计值，即一个估计概率分布。
这样，我们便可以计算歌曲集中的歌曲\emph{s}对应的概率分布与这个估计概率分布的距离。显然，如果\emph{s}与目标歌曲\(\hat{s}\)距离足够小，那么我们就可以将歌曲\emph{s}推
荐给用户\emph{u}。因此，我们可以用\emph{s}与目标歌曲\(\hat{s}\)的距离的倒数表示歌曲集中任一歌曲\emph{s}对用户\emph{u}的推荐度，即上文定义的效用函数\emph{utility(u,s)}，
如式3.14所示。

\begin{equation}
utility(u,s)=\frac{1}{1+dis(s,\hat{s})}
\end{equation}

因为我们是通过主题模型建模将歌曲表示成离散的概率分布，所以我们可以使用KL距离(Kullback-Leibler Divergence)~\cite{kullback1951information}以及Hellinger距
离~\cite{oosterhoff2012note}等来度量两首歌曲之间的距离。考虑到KL 距离不具有对称性，本文采用Hellinger距离来度量歌曲之间的距离，如式3.15所示。

\begin{equation}
dis({s}_{i},{s}_{j})=\frac{1}{\sqrt{2}}\sqrt{\sum_{k=1}^{K}({\sqrt{{\omega}_{ik}}-\sqrt{{\omega}_{jk}}})^{2}}
\end{equation}


其中，\(dis({s}_{i},{s}_{j})\)为编号为\emph{i}和\emph{j}的歌曲对应的主题概率分布之间的Hellinger距离，\emph{K}为隐含主题数目，\({\omega}_{ik}\)为编号为\emph{i}的歌
曲在第\emph{k}个隐含主题上的隶属程度。显然，当两首歌曲越相似，那么其对应的距离越小。相反的，若两首歌曲越不相似，其主题概率分布对应的距离越大。

\section{推荐列表生成}

最后，我们根据效用函数计算歌曲集\emph{S}中所有歌曲的效用值，然后根据效用值对歌曲排序，并将排名最高的N首推荐给用户，这样我们就为用户\emph{u}推荐了一个长度为\emph{N}的
歌曲列表供用户选择。

\section{实验设计和结果}

本节我们将通过实验来验证本文所给的基于多维时间序列分析的音乐推荐方法的有效性，包括实验的设计思路、实验结果以及结果分析等内容。

\subsection{数据收集}

通过对基于多维时间序列分析的音乐推荐算法的分析，可以看出我们需要的数据集主要包括包含标签文本信息的歌曲数据集以及用户在一定会话周期内所收听的歌曲序列的数据集。
虽然Berenzweig等人于2003年从Art of the Mix(http://www.artofthemix.org/)上抓取了播放列表数据集~\cite{berenzweig2004large}，但是其存在如下三个问题：

\begin{enumerate}
\item 缺少歌曲对应的标签等文本信息。
\item 歌曲名称经过处理，无法与Lastfm对应，导致可用数据较少。
\item 给出的播放列表意义不清，没有时间信息，无法确定是用户在一个会话周期内的行为，可能跨越多个会话周期。
\end{enumerate}

为此，我们从Last.fm上重新爬取了一个数据集。该数据集既包含歌曲的基本信息(包括标签等文本信息)也包含用户的基本信息(包括用户在一定会话周期内所收听的歌曲列表)。
为了减少噪音，我们只选用包含歌曲数目多于10首的列表，出现频次大于10的标签以及可用标签大于4 的歌曲。该数据集的统计信息如表3.2所示，目前该数据集已经发布
在http://lastfmseq.sinaapp.com/上，而其具体的使用说明如附录A所示。

\begin{table}[!hbp]
\caption{所用数据集信息}
\centering
\begin{tabular}{|c|c|}
\hline
听歌事件 & 34930 \\
\hline
歌曲总数 & 24992 \\
\hline
用户总数 & 1530 \\
\hline
歌手总数 & 5479 \\
\hline
最大长度 & 10 \\
\hline
最小长度 & 30 \\
\hline
平均长度 & 22.83 \\
\hline
\end{tabular}
\end{table}

\subsection{评测标准}

对于用户\emph{u}，我们通过对其收听记录所形成的有序列表进行分析，为其生成一个包含\emph{N}首歌曲的推荐歌曲列表，如果这\emph{N}首歌曲中包含用户真实收听的下一首歌曲，那么我们认为
这个对于用户\emph{u}的推荐是有效的。显然，类似音乐推荐这种为用户推荐一组物品供选择的问题是典型的Top-N推荐问题(Top-N Recommendation, TNR)。
由文献~\cite{adomavicius2005toward}~\cite{powers2011evaluation}可知，召回率(recall) 和准确率(precision)是衡量一个Top-N推荐算法优劣的重要标准，我们这里也用这
两种标准来评测本文提出的方法。记\(R(u)\)是根据用户在训练集上的行为给用户推荐的歌曲列表，而\(T(u)\)是用户在测试集上的行为列表，那么表征“检索出的相关文档数和文档库中所
有的相关文档数的比率”的召回率\emph{recall}的定义如式3.16所示。

\begin{equation}
recall=\frac{\sum_{u\in{U}}|R(u)\cap{T(u)}|}{\sum_{u\in{U}}|T(u)|}
\end{equation}

可以看出，召回率表征用户真实收听的歌曲被推荐的数目与用户真实收听歌曲总数的比率。因为在音乐推荐系统中，用户\emph{u} 同一时刻在测试集上只会收听一首歌曲，即\(|T(u)|=1\)。
因此，我们将式3.16简化为如式3.17所示的命中率(hit ratio)。

\begin{equation}
hitRatio=\frac{\sum_{u\in{U}}hit(u)}{|U|}
\end{equation}

其中，\emph{N}为推荐系统为用户推荐的歌曲数目，\emph{hit}表示用户实际收听的歌曲是否在推荐列表中，若在则为1，否则为0。如果\emph{hit}为1，我们称之为“命中一次”。
记用户\emph{u}实际收听的歌曲为\emph{s}，则\emph{hit}可表示为如式3.18。

\begin{equation}
hit(u)=\left\{
\begin{aligned}
1   ,s\in{R(u)} \\
0   ,s\notin{R(u)}
\end{aligned}
\right.
\end{equation}

准确率\(precision\)表征了“检索出的相关文档数和系统所有检索到的文件总数的比率”，即用户真实收听的歌曲被推荐的数目与被推荐的歌曲总数的比率，其定义如式3.19所示：

\begin{equation}
precision=\frac{\sum_{u\in{U}}|R(u)\cap{T(u)}|}{\sum_{u\in{U}}|R(u)|}
\end{equation}

考虑到\(|T(u)|=1\)，式3.19可简化为式3.20。

\begin{equation}
precision=\frac{\sum_{u\in{U}}hit(u)}{\sum_{u\in{U}}|R(u)|}
\end{equation}

考虑到召回率和准确率此消彼长的关系，文献[21]中使用F1-Score对模型进行评估，F1-Score的取值越大那么模型对应的综合效果越好，反之越差。F1-Score可以用式3.21表示：

\begin{equation}
F1=2*\frac{recall*precision}{recall+precision}
\end{equation}

在如上所述的评测标准中，召回率和准确率的在很大程度上取决于如式3.17所示的命中率。如果歌曲未被用户喜欢或收听，那么就认为该歌曲未命中。然而，
文献~\cite{su2013personalized}指出没有明显的证据表明未被评分的物品对用户来说是完全否定的。也就是说，即使歌曲未命中，也不代表用户不喜欢该歌曲。假设用户\emph{u}真实
收听的下一首歌曲为”同桌的你“，如果系统为其推荐了列表(”北京北京“，”存在“，”同桌的你“)，那么我们认为该推荐是有效的，因为目标歌曲”同桌的你“在推荐列表中。
相反，如果系统为其推荐列表(”白桦林“，”睡在我上铺的兄弟“，”一生有你“)，由于其中未包含目标歌曲”同桌的你“，我们认为该推荐是无效的。然而，第二个推荐列表中的歌曲与目标歌曲
”同桌的你“都属于经典校园民谣，用户显然也会喜欢该列表，因此认为第二个推荐无效就不够合理；第一个推荐列表中除了”同桌的你“之外其余两个都偏”摇滚“，这个列表对于喜好校园
民谣的用户来说也并不一定有效。

为了解决这种矛盾，我们可以考虑使用推荐偏差的大小来衡量算法的优劣。也就是说，推荐偏差越小，算法越好，反之越差。这里的偏差可以用歌曲对应的主题概率分布的Hellinger距
离来表示。如果一个推荐列表中歌曲与目标歌曲的整体相似度较高，那么该列表中歌曲与目标歌曲的距离就应该较小，即推荐偏差较小，这时即使目标歌曲不在该列表中，我们也应该
认为该列表合理。而如果一个推荐列表中的歌曲与目标歌曲的相似度整体偏低，导致推荐偏差较大，即使其中包含目标歌曲，我们也应该降低该列表被认可的权重。推荐系统主要包含
评分预测和Top-N推荐两类问题，在评分预测中我们常常使用均方根误差(RMSE)和平均绝对误差(MAE)来衡量算法的优劣，这里我们将其借鉴到音乐推荐的问题中并用以衡量不同算法的
优劣，其定义如式3.22和3.23所示。

\begin{equation}
RMSE=\sqrt{\frac{\sum_{u\in{U}}{e(u)}^{2}}{|U|}}
\end{equation}

\begin{equation}
MAE=\sqrt{\frac{\sum_{u\in{U}}|e(u)|}{|U|}}
\end{equation}

其中，\emph{U}为测试用户集，\(|U|\)为用户数，\(e(u)\)为向用户推荐的结果的误差。考虑到我们为用户推荐的是一个列表，我们将\(e(u)\)看做是列表中所有歌曲与目标歌曲的平
均距离。如式3.24所示。

\begin{equation}
e(u)=\frac{\sum_{s\in{R(u)}}dis(s,{s}_{\pi+n+1})}{|R(u)|}
\end{equation}

\subsection{实验设置}

为了客观地衡量本文所述方法的效果，我们首先将所有数据随机地分为10份并将其中的9份作为训练集，剩余的1份为测试集，然后进行10轮交叉实验。最后，我们将10轮实验的结果进行
平均，从而得到最终的实验结果。其中，本文将隐含主题数目设为30。本文实验实在Dell Optiplex74的台式机上进行，操作系统为Ubuntu12.04，CPU为Intel 酷睿2 E6300，内存大小
为2G，硬盘空间160G。实验所用编程语言为Python2.7。

\subsection{结果分析}

图3.5展示了当被推荐歌曲数目\emph{N}由1到100的增长过程中，不同推荐算法的召回率的变化情况，这里包括基于用户的协同过滤算法(UserKNN)~\cite{resnick1994grouplens}、
基于模式挖掘的推荐算法(PatternMining)~\cite{hariri2012context}、基于马尔科夫模型的推荐算法(1st-Markov)~\cite{mcfee2011natural}、基于全局特征的推荐算法(Global)
~\cite{chordia2008extending}、 基于用户即时行为的音乐推荐(Local)~\cite{hyung2012music}以及本文提出的基于多维时间序列分析的音乐推荐方法(Music Recommendation
Based on Multidimensional Time Series Analysis, MTSA)。 其中，横坐标表示被推荐歌曲的数目，纵坐标表示算法的召回率。由图3.5可以看出，代表本文所述方法的曲线与其他
曲线能够明显分开且位于其他曲线之上，表明本文所提方法能够获得比其他同类工作更好的召回率且提升效果比较明显。此外，随着被推荐歌曲数目的增加，本文所述方法的召回率也
同时提升且呈逐渐上升趋势。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/hitratio.eps}
\caption{不同推荐算法在命中率上的表现}
\label{fig_hitratio}
\end{center}
\end{figure}

图3.6展示了随着推荐列表长度增加，不同推荐算法的推荐准确率变化情况。从图中可以非常直观地看出，虽然随着推荐列表长度的增加，所给几种推荐算法的准确率都有所下降，但
本文所给出的基于多维时间序列分析的音乐推荐算法能够取得最好的推荐准确率。需要说明的是，随着推荐列表长度的增加，各算法推荐准确率取值比较低且持续下降是可以从准确率
的定义中推导出来的。假设用户数目为100，推荐列表长度为50，推荐算法的命中率为60\%即命中数为60，那么此时的推荐准确度为 0.012。 当推荐列表长度增加到100 时，假设推荐
算法的命中率提升到80\%即命中数为80，那么此时的推荐准确率只有0.008。简单来说，对于音乐推荐来说，准确率定义中的分子变化很小且取值也很小但分母却增长地比较快，所以
导致了推荐准确率取值很小且随着推荐列表长度增加，准确率不断下降。因此，预测准确率偏低以及随着推荐列表增加而降低是可以解释的，而我们关注地不是其绝对取值，
更大的意义上我们关注不同推荐算法获得的推荐准确率之间的相对效果。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/precision.eps}
\caption{不同推荐算法在准确度上的表现}
\label{fig_precision}
\end{center}
\end{figure}

为了更为直观地考察本文所提方法在推荐准确率指标上的提升效果，我们下面使用相对指标进行评测。考虑到基于用户的最近邻算法(UserKNN)在同类工作中得到的关注最多，本文考察
基于多维时间序列分析的音乐推荐方法相较于UserKNN在推荐准确率上的提升效果(倍数)，如图3.7所示。其中，横坐标表示被推荐歌曲的数目，纵坐标表示算法推荐准确率的提升倍数。
如果纵坐标取值大于零，表明本文所述方法的推荐准确率相较于UserKNN算法有所提升；如果纵坐标取值为零，表明效果没有提升；如果纵坐标取值小于零，表明本文所述方法不但没
有提高推荐准确度而且还有所下降。由图3.7可以看出，无论被推荐歌曲数目为何值，纵坐标取值总是大于零，说明本文所述方法能够提升推荐的推荐准确率且提升幅度在80\% 以上。
随着推荐列表长度的增长，提升的幅度也继续增长(可达150\%)。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/improvement.eps}
\caption{本文方法相对于UserKNN在F1-Score指标上的提升}
\label{fig_improvement}
\end{center}
\end{figure}

图3.8和3.9展示了随着推荐列表长度的增加，几种不同的音乐推荐算法的均方根误差(如图3.8所示)和平均绝对误差(如图3.9所示)的变化趋势。其中，横坐标表示被推荐歌曲的数目，
纵坐标表示不同推荐算法的误差。由图可以直观地看出，本文所提方法的推荐误差较之其他几种算法都比较小。随着推荐列表长度的增加，列表中无效的歌曲增多，使得推荐误差有
所上升，但这种上升幅度也是是非常小的。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/rmse.eps}
\caption{不同推荐算法在均方根误差上的表现}
\label{fig_rmse}
\end{center}
\end{figure}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/mae.eps}
\caption{不同推荐算法在绝对误差上的表现}
\label{fig_mae}
\end{center}
\end{figure}

综合以上实验结果可以看出，无论是从命中率/准确率的角度去考察算法的优劣，还是从预测误差的角度去考察算法的优劣，本文所述的基于多维时间序列分析的音乐推荐算法都能够
取得比参考算法较好的效果。这验证了本文所提方法的合理性，说明将用户行为建模为一个多维时间序列进行分析能够全面细致地实现对用户行为的刻画进而提升推荐效果。

\chapter{基于用户长期行为、中期行为和即时行为的综合音乐推荐方法}
\label{C:intergrated}

由前文可知，基于多维时间序列分析的个性化音乐推荐方法与一些参考推荐方法相比能够取得比较好的推荐效果，这包括较高的推荐命中率和较低的预测误差两方面的含义。
但是，朴素的多维时间序列分析音乐推荐方法还存在以下问题：

\begin{enumerate}
\item 考察片面。该方法主要是通过对用户当前会话期内的行为序列进行分析来预测用户接下来的行为，显然其只考虑了用户中期行为对用户未来行为的作用却忽视了用户长期行为以及
用户即时行为的影响，这与用户的未来行为受到其长期行为、中期行为和即时行为共同作用的直觉不相符。

\item 冷启动问题。该方法顺利工作的前提是用户已经产生了一些行为，即用户已经在当前会话期内收听了一定数量的歌曲。也就是说，朴素的基于多维时间序列分析的音乐推荐方法
适合在用户状态稳定时为用户做出合理的推荐。但是，对于刚进入给定平台的用户，朴素方法的推荐效果就要大打折扣，这是因为用户刚进入给定平台时所产生的行为很少，而对应的
听歌序列还不足以被朴素的多维时序方法进行分析和预测。
\end{enumerate}

为了解决上述两个问题，我们将在本章中给出一种基于用户长期、中期和即时行为的综合音乐推荐方法并通过实验验证综合推荐的效果。最后，本文对综合音乐推荐中的一些基本问题
进行讨论分析，比如会话期长度的选择和文本分析方法的选取等。

\section{综合音乐推荐}

为了综合考虑用户长期、中期和即时行为对用户未来行为的影响和作用，本文从基于用户长期行为的音乐推荐、基于用户中期行为的音乐推荐以及基于用户即时行为的音乐推荐中各选择一种
算法进行综合，试图通过这种综合全面考察用户行为的时间相关性。至于如何对不同的算法进行综合，有很多策略可以进行选择。Burke的分类方法~\cite{burke2002hybrid}区分出了
七种不同的综合策略，而从更综合的角度来看这七种策略可以概括为三种基本设计思想：整体式综合设计、并行式综合设计和流水线式综合设计。其中，整体式混合设计实际上是一种
推荐算法，其在推荐内部对不同推荐策略获取的特征进行混合，然后基于此做出最终推荐列表；并行式混合设计和流水线式混合设计都需要至少实现两个不同的推荐算法，其中并行式
混合设计将不同推荐算法获取的最终推荐结果加以混合，而流水线式混合则将推荐分为不同的阶段然后在不同的阶段使用不同的推荐策略进行推荐并最终得到推荐结果。

显然，本文所述的音乐推荐不具有明确的阶段划分，因此使用流水线式的混合设计不太合适，而整体式混合设计和并行式混合设计均可应用，只是二者混合的阶段不一致。由于整体式的
混合设计思路是从内部对不同推荐策略的结果进行混合，我们认为这样的早期混合能够得到比较符合用户偏好的特征，因此我们主要考察这种混合设计方法，如图4.1所示。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.9\textwidth]{figures/hybrid.eps}
\caption{基于用户长期、中期和即时行为的综合音乐推荐方法示意图}
\label{fig_hybrid}
\end{center}
\end{figure}

考虑到用户的未来行为受到用户长期行为、中期行为和即时行为的共同影响，我们从这三类算法中各选择一种预测出用户可能收听的下一首歌曲在\emph{K}个隐含主题上的概率分布。
然后，我们使用一定的综合策略将这三个中间概率分布加以综合以得到最终的目标概率分布。在此基础上，我们计算曲库中所有歌曲对应的概率分布于目标概率分布的相似度并将歌曲
按照相似度由大到小排列。最后，我们将排名靠前的\emph{N}首歌曲推荐给用户。要实现这样一个基于用户长期、中期和即时行为的综合音乐推荐，有两个难点需要解决：

\begin{enumerate}
\item 如何从基于用户长期行为、中期行为和即时行为的音乐推荐方法中选择带具体的待综合算法。

\item 采用何种综合策略对给定的三种音乐推荐方法进行综合。
\end{enumerate}

\subsection{方法选取}

在需要选择的三种音乐推荐方法中，最容易选择的自然是基于用户中期行为的音乐推荐方法，本文给出的基于多维时间序列分析的音乐推荐方法就是一种基于用户中期行为的音乐推荐，
而且该方法能够取得比较理想的推荐效果。假设使用基于多维时间序列分析的音乐推荐方法预测得到的用户可能收听的下一首歌曲对应的概率分布为\({\vec{s}}_{mtsa}\)，如式4.1所示。

\begin{equation}
{\vec{s}}_{mtsa}=({\omega}_{1\_mtsa},...,{\omega}_{i\_mtsa},...,{\omega}_{K\_mtsa})(1\le{i}\le{K})
\end{equation}

至于基于用户长期行为的音乐推荐方法的选取，我们选择朴素的全局特征推荐。与基于协同过滤的推荐相比，基于全局特征的音乐推荐实现起来比较简单，而且能够预测得到用户的整体
偏好，其得到的结果与本文所给的基于多维时间序列分析的音乐推荐方法一致，方便后续综合。基于全局特征的推荐认为用户长时间的听歌行为在一定程度上能够比较用户内在的音乐偏好，
进一步地此类算法认为用户下面可能收听歌曲的特征近似于用户所收听的全部歌曲的平均特征。对于用户集中收听了\(\pi+n\)首歌曲的用户\emph{u}来说，我们设使用基于全局特征推荐得到
的目标概率分布为\({\vec{s}}_{global}\)，如式4.2所示。

\begin{equation}
{\vec{s}}_{global}=({\omega}_{1\_global},...,{\omega}_{i\_global},...,{\omega}_{K\_global})(1\le{i}\le{K})
\end{equation}

其中，目标歌曲在第\emph{i}个隐含主题上的概率取值如式4.3所示，\emph{j}表示用户收听的第\emph{j}首歌曲的索引。

\begin{equation}
{\omega}_{i\_global}=\frac{\sum_{j=1}^{\pi+n}{\vec{s}}_{j}(i)}{\pi+n}
\end{equation}

在选定了基于用户中期行为和长期行为的音乐推荐方法之后，我们需要进一步选取基于用户即时行为的音乐推荐方法。基于用户即时行为的音乐推荐思想比较简单，即认为用户的状态是
稳定的，进一步地认为用户可能收听的下一首歌曲与用户当前收听的歌曲具有类似的特征。对于用户集中收听了\(\pi+n\) 首歌曲的用户\emph{u}来说，我们设使用基于即时特征推荐得到
的目标概率分布为\({\vec{s}}_{local}\)，如式4.4所示。

\begin{equation}
{\vec{s}}_{local}=({\omega}_{1\_local},...,{\omega}_{i\_local},...,{\omega}_{K\_local})(1\le{i}\le{K})
\end{equation}

其中，目标歌曲在第\emph{i}个隐含主题上的概率取值如式4.5所示，\emph{j}表示用户收听的第\emph{j}首歌曲的索引。

\begin{equation}
{\omega}_{i\_local}={\vec{s}}_{\pi+n}(i)
\end{equation}

\subsection{综合策略}

在给定了三种类型的音乐推荐方法之后，我们还需要选择合理的综合策略将它们综合起来。加权是一种非常重要的综合思想，其一方面可以将不同的推荐策略综合起来考虑，另一方面
能够通过权重调整不同推荐策略的影响和贡献，本文所给出的这种基于用户长期、中期和即时行为的音乐推荐方法正是使用这种思想来完成对用户长期行为推荐、中期行为推荐以及即时行为推荐的综合
。在使用三种不同的音乐推荐方法预测得到三种不同的中间概率分布即\({\vec{s}}_{mtsa}\)、\({\vec{s}}_{global}\) 和\({\vec{s}}_{local}\)之后，我们按照如式4.6所示的方法对
它们进行综合以得到最终的目标概率分布\({\vec{s}}_{all}\)。

\begin{equation}
{\vec{s}}_{all} = \alpha{\vec{s}}_{mtsa}+(1-\alpha)(\beta{\vec{s}}_{global}+(1-\beta){\vec{s}}_{local})
\end{equation}

目标概率分布中每一维的取值可以按照式4.7获得。

\begin{equation}
{\hat{\omega}}_{i\_all}(\pi+n+1)=\alpha{\hat{\omega}}_{i\_mtsa}(\pi+n+1)+(1-\alpha)(\beta{\hat{\omega}}_{i\_local}(\pi+n+1)+(1-\beta){\hat{\omega}}_{i\_global}(\pi+n+1))
\end{equation}

其中,\(\alpha\)表示基于用户中期行为的音乐推荐方法对应的权重，\(\beta\)是用以调整基于用户长期行为和基于用户即时行为推荐方法贡献的参数。对于公式4.6和4.7，我们按照
式4.7定义参数\(alpha\)。由于我们不是主要研究基于用户长期行为和即时行为的音乐推荐，因此我们不过分关注参数\(\beta\)的变化。为方便起见，我们给定\(\beta=0.5\)，即基于
用户长期行为的推荐和基于用户即时行为的音乐推荐具备相同的权重。

\begin{equation}
\alpha=\frac{f(n-b)}{n+a}
\end{equation}

式4.7中，\emph{n}表示用户在当前会话期内所收听的歌曲的数目，即用户当前会话序列的长度；\emph{a}和\emph{b}是用以调整\(\alpha\)变化的参数，它们共同确定了基于用户中期行为
的推荐何时起作用以及变化趋势；算子f的定义式4.8所示。

\begin{equation}
f(x)=\left\{
\begin{aligned}
x     ,x>0 \\
0     ,x\le{0}
\end{aligned}
\right.
\end{equation}

图4.2给出了当a=10且b=5时，\(\alpha\)的取值变化情况，其中横坐标表示用户当前会话序列的长度，纵坐标表示\(\alpha\)的取值。由图可以看出，当序列长度小于5时\(\alpha=0\)
，这背后体现的思想是：序列长度过短时基于用户中期行为的音乐推荐不起作用，此时主要使用基于用户长期行为的音乐推荐和基于用户即时行为的音乐推荐为用户作出推荐，这在一定
程度上解决了冷启动问题；随着纵坐标的增加，用户当前会话序列不断增长，\(\alpha\)的取值不断增加，这背后的含义是：基于用户中期行为的推荐在用户状态稳定时比较有效且随着
用户行为的增加，可分析的信息增多，基于用户中期行为的推荐所起的作用应增强。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/alpha.eps}
\caption{Alpha变化示意图}
\label{fig_alpha}
\end{center}
\end{figure}

\section{实验结果}

为了评估本节所给出的基于用户长期、中期和即时行为的综合推荐方法的效果，我们将之与第三章中给出的朴素的基于多维时间序列分析的音乐推荐方法进行比较。实验所采用的数据集、实验条件
设置、实验评测指标等信息与3.7节中所述一致。

图4.3展示了基于用户长期、中期和即时行为的综合音乐推荐和朴素的基于多维时间序列分析的音乐推荐方法在命中率指标上的表现。其中，横坐标表示推荐列表的长度，纵坐标表示推荐命中率，MTSA
表示朴素的时序推荐方法，MTSA\_ALL表示综合推荐方法。由图可以非常直观地看出，基于用户长期、中期和即时行为的综合音乐推荐方法能够取得比朴素的时序分析方法更高的命中率。图4.4展示了这
两种方法在均方根误差这一评测指标上的表现。其中，纵坐标表示均方根误差，纵坐标取值越小，误差越小，算法的推荐效果越好。由图4.4可以看出，综合的推荐方法能够取得比朴素时序
分析方法更低的预测误差。这两类算法在准确率、F1-Score、平均绝对误差等指标上的表现与其在命中率和均方根误差上的表现类似，这里不再赘述。

由实验结果可以看出，本文所给出的基于用户长期、中期和即时行为的音乐推荐方法确实能够提升朴素的多维时序分析方法的推荐效果，这从侧面也验证了用户的未来行为是受到用户中期行为、长期行
为和即时行为共同作用和影响的。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/hybrid_hitratio.eps}
\caption{综合方法与基本方法在命中率指标上的比较}
\label{fig_hybrid_hitratio}
\end{center}
\end{figure}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/hybrid_rmse.eps}
\caption{综合方法和基本方法在预测误差指标上的比较}
\label{fig_hybrid_rmse}
\end{center}
\end{figure}

\section{分析讨论}

本文上面分别介绍了本文所给出的一种基于多维时间序列分析的个性化音乐推荐方法以及以此为基础构建的一种基于用户长期、中期和即时行为的综合音乐推荐方法，本节将就其中一些细节问题
进行简单地分析和讨论，主要包括最大分析长度的设定以及不同文本建模方法的比较。

\subsection{最大分析长度}

本文所述的基于多维时间序列分析的个性化音乐推荐方法及综合音乐推荐方法主要关注地是用户在当前会话期内所收听(喜欢)歌曲构成的序列，那么如果用户在当前会话期内收听了很
多首歌曲(假如是1000首)，我们是不是要对所有这些歌曲构成的序列进行分析呢？显然，这么做既不划算也不合理，因为用户所处的上下文环境是时刻改变的，很久之前的行为对当
前环境状态的表征作用很有限甚至会形成干扰。为此，我们设置一个“最大分析长度”，这样我们只需要对一定范围内的序列进行分析即可，既减轻了计算的负担同时也排除了老旧数
据的干扰。顾名思义，“最大分析长度”就是从当前时刻算起，算法所考察的用户行为序列的最大长度。假如设置最大分析长度为4，对于依次收听了歌曲\({s}_{1}\)、\({s}_{2}\)
、\({s}_{3}\)、\({s}_{4}\)、\({s}_{5}\)、\({s}_{6}\)、\({s}_{7}\)的用户来说,算法只分析由\({s}_{4}\)、\({s}_{5}\)、\({s}_{6}\)、\({s}_{7}\)构成的序列而忽略\({s}_{1}\)、
\({s}_{2}\)、\({s}_{3}\)。如果调整最大序列长度为3，那么歌曲\({s}_{4}\)也将被忽略，算法只考察由\({s}_{5}\)、\({s}_{6}\)、\({s}_{7}\)构成的序列。图4.5展示了随着最
大可分析长度的增加，本文给出的多维时序推荐方法在命中率指标上的表现(推荐列表长度设为100)。图中横坐标表示最大可分析长度，纵坐标表示算法的命中率。由图可以看出，对当
前数据集来说，当最大分析长度为15时，算法的命中率基本就保持稳定了，这说明更早之前的数据对提升命中率意义不大。因此，可以取最大分析长度为15。当然，不同的数据集
最大分析长度取值不一样，但差别不大，一般取15~30为宜。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/windowsize.eps}
\caption{不同最大分析长度对应的命中率}
\label{fig_windowsize}
\end{center}
\end{figure}

\subsection{不同文本分析方法比较}

我们在第二章介绍了向量空间模型、词频-逆文本频率模型、隐含狄利克雷分配等几种不同的文本建模方法，同时提到LDA模型与VSM 模型和TF-IDF模型相比，一方面能够更好地描述文档的
文本特征，另一方面可以解决一词多义和一义多词的问题，因此本文所述的基于多维时间序列分析的音乐推荐方法和基于用户长期、中期和即时行为的音乐推荐方法在对歌曲集对应的文档集进行建
模时都采用了LDA模型。为了直观地展现LDA模型的好处，本节通过实验来展现使用不同的文本建模方法来执行基于用户即时行为推荐所获得的命中率，如4.6图所示。其中，横坐标表示
推荐列表的长度，纵坐标表示算法获得的命中率。纵坐标取值越大，算法获得命中率越高，算法推荐效果越好。由图可以非常直观地看出，使用隐含狄利克雷分配对文档集进行建模确实
能够得到比传统的向量空间模型和词频-逆文本频率更好的推荐效果。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/textmodel.eps}
\caption{不同文本建模方法的效果比较}
\label{fig_textmodel}
\end{center}
\end{figure}

\chapter{系统实现}
\label{C:system}

前述章节我们介绍了一种基于多维时间序列分析的音乐推荐方法和在此基础上的一种基于用户长期、中期和即时行为的音乐推荐方法，并通过实验从多个角度验证了本文上述的有效性。为了进一步验证上述方法的可行性并解决系统实现中的一些关键问题，本文实现了一个个性化音乐推荐原型系统,即Sweetfm。本章我们将对该原型系统进行详细介绍并给出一些具体的技术方案。

\section{系统架构}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/xlvector.eps}
\caption{推荐系统和网站其他系统之间的关系}
\label{fig_xlvector}
\end{center}
\end{figure}

尽管优秀的推荐算法能够为用户推荐合理的结果，但只靠推荐很难构成一个完整的可用系统。要构建一个可用的推荐系统，比如一个音乐推荐网站，就需要考虑推荐与系统其他组件的关系，只有这样才能最终实现推荐的价值。项亮在文献~\cite{xlvector2012} 中给出了如5.1所示的一般意义上推荐系统和网站其他系统之间的关系。首先，基本上所有的网站都配有一个用户界面，即UI系统，该系统主要用来向用户展示页面效果以及与用户进行交互。其次，网站往往还会配置日志系统，该系统主要用来将用户在用户界面上的各种有效行为记录下来并保存到对应的日志存储系统中。需要注意的是，这里的日志存储系统既可以是数据库，也可以是缓存，还可以是文件系统。推荐系统作为一个推荐网站的核心，其主要作用是分析存储在日志存储系统中的用户行为历史，在此基础上生成该用户对应的推荐列表并将结果直接展示到用户界面上以供用户体验。由图5.1可知，推荐系统要想将强大的作用发挥出来，需要依赖于用户的历史行为信息和用户界面等组件。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.9\textwidth]{figures/system.eps}
\caption{原型系统框架}
\label{fig_system}
\end{center}
\end{figure}

5.1图虽然给出了一般意义上的推荐系统的架构，给本文所实现的原型系统带来了很大启发，但这种架构过于简单，不能直接用于本文的原型系统。在认真分析本文所提推荐方法框架的基础上，本文按照图5.2对原型系统进行设计。

本文所实现的原型系统主要包括客户端、用户服务接口、处理层和数据层构成。客户端对应于图5.1中的UI 系统，旨在为用户提供一个可以收听推荐歌曲并产生交互的窗口，具体到实现上既可以使用Web，也可以是Mobile还可以是普通的窗口客户端。

用户服务接口用于将用户在客户端上的行为传递给后续模块进行处理以及将推荐的结果返回给客户端。

处理层主要用于完成相关数据处理，其包括在线处理模块和离线处理模块。其中，离线处理模块主要包括从百度音乐、豆瓣音乐、虾米音乐、Lastfm等数据源爬取歌曲基本属性数据和标签数据的爬虫系统以及对歌曲对应的文档集合进行语义分析以获取每一首歌曲对应的隐含主题分布的语义分析模块。需要强调的是，这里离线的含义是指该模块的工作与用户行为无关，在具体实现上可以设定一定的时间间隔或周期重复执行。

在线处理模块主要用于实时记录和处理用户的行为并为之生成最终推荐结果，其主要包括日志系统、序列生成系统、标签系统以及Storm推荐引擎几个部分组成。日志系统对应于文献\cite{xlvector2012}中的日志系统，用于将用户的行为记录到数据存储系统中以待后续分析。标签系统主要用于记录用户对当前所听歌曲所标注的标签，其与离线模块中的爬虫系统一起生成最终的歌曲标签信息，一定周期后可供语义分析模块处理。序列生成系统用于根据用户在当前会话期内的行为生成对应的歌曲序列。Storm推荐引擎模块的主要作用是使用Storm框架对用户当前会话期的歌曲序列进行实时分析并产生最终的推荐结果。

数据层主要完成用户属性、歌曲属性以及用户行为的存储功能，其包括数据库接口DAO以及具体数据库两部分。其中，数据库接口提供供其他层次模块调用的方法以避免直接操作数据库，增强了独立性。具体数据库即真实的数据存储引擎，既可以是Mysql，也可以是Oracle，当然也可以是SQLServer。
　　　
用户产生一个积极行为到系统为其推荐歌曲的过程如下所示：

\begin{enumerate}
\item 用户在客户端产生“即将收听完当前歌曲”的行为。

\item 用户服务接口接收用户的当前行为状态并将该状态传递给在线处理模块中的日志系统和序列生成系统。

\item 日志系统将用户当前行为状态通过数据库接口DAO记录到数据库中。

\item 序列生成系统通过数据库接口DAO读取日志数据库中的用户行为，构建其在当前会话期的收听序列并将该序列传递给Storm 推荐引擎。

\item 推荐引擎对用户当前会话期的收听序列进行分析和处理，生成推荐列表并通过数据库接口保存到数据库。

\item 用户服务接口通过数据库接口从数据库中读取推荐列表。

\item 用户服务接口将推荐列表展示给用户。
\end{enumerate}
　　　
用户对歌曲打标签的执行过程如下所示：

\begin{enumerate}
\item 用户在客户端选定一首歌曲。

\item 用户为选定歌曲打标签。

\item 用户服务接口接收用户的打标签行为以及打标签的对象和标签内容并将它们传递给在线处理模块中的标签系统。

\item 标签系统对标签进行分析和处理。

\item 标签系统将处理过的内容通过数据库接口DAO保存到数据库中。
\end{enumerate}
　　　
类似地，可以给出用户其他行为的处理过程。

\section{离线处理模块}

如上所述，离线处理模块所做的工作主要包括爬虫系统和语义分析系统两部分组成，这些工作都是独立于用户进行的，所以称之为离线。本节将详细介绍上述框架中的离线处理模块中设计的一些技术和工具，而作为算法核心的语义分析模块将是介绍的重点内容。

\subsection{爬虫系统}

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.3\textwidth]{figures/crawlSpider.eps}
\caption{爬虫系统工作流程图}
\label{fig_spider}
\end{center}
\end{figure}

网络爬虫是一种能够按照一定地规则自动地抓取互联网上的网页并对网页内容进行解析的网络机器人，又称之为网络蜘蛛。本文所实现的音乐网络爬虫首先从豆瓣、虾米、百度等音乐网站上抓取相关歌曲网页，然后对网页的HTML 进行分析和解析，进而得到歌曲的名称、创作者、发行时间、歌词等基本属性以及用户对歌曲所打的标签内容，最后将这些内容进行整理并保存到数据库中。对于一个待抓取的歌曲页面URL，本文按照流程图5.3进行工作。

网络爬虫目前已经广泛应用在数据挖掘、搜索引擎、信息检索、推荐系统等领域，同时也出现了很多网络爬虫框架以简化爬虫的实现。其中，Scrapy~\cite{Scrapy}是一种纯python 实现且构建于异步框架 twisted 之上爬虫框架，其用户只需要定制开发几个模块就可以轻松地实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。要想创建一个网络爬虫，用户只需要执行命令scrapy startproject projectname就可以得到如图5.4所示的项目目录，生成的目录中包含若干文件，代表Scrapy框架中的多个模块。用户只需要在对应的文件中实现相应模块即可。其中，items.py文件对应于Scrapy中的项模块，用于定义抓取结果中单个项所需要包含的所有内容，如歌曲的名称、创作者、发行时间等；piplines.py对应于Scrapy中的管道模块，定义如何对抓取到的内容进行再处理，例如输出文件、写入数据库等；spider目录下存放写好的爬虫实际抓取逻辑。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.3\textwidth]{figures/scrapy.eps}
\caption{Scrapy结构示意图}
\label{fig_scrapy}
\end{center}
\end{figure}

由上可知，在抓取指定网页内容之后需要对网页进行解析，这里我们使用Python语言的第三方包BeautifulSoup~\cite{BeautifulSoup}来解析下载下来的歌曲网页对应的HTML文件。BeautifulSoup 使用起来非常简单，可以非常容易地完成对HTML文件的解析，同时它也支持按照不同的条件来查找相关元素，比如按标签查找、按属性查找、按名称查找、按结构查找等。

\subsection{结巴分词}

由信息检索等相关知识可知，要对文本进行分析，往往首先需要进行分词，即将连续的字序列按照一定的规范重新组合成词序列的过程。比如将句子“南京市长江三桥”分成“南京/市长/江三桥”或者“南京市/长江/三桥”这样的词汇序列。目前，学术界和工业界也出现了众多成熟的分词工具，比如基于词频词典的机械中文分词引擎SCWS、中科院的汉语词法分析系统ICTCLAS(Institute of Computing Technology, Chinese Lexical Analysis System)、基于HTTP 协议的开源中文分词系统HTTPCWS以及支持多种分词模式的结巴分词等。考虑到各工具的效率、可用性、精度以及源码获取难易程度，本章所述原型系统采用结巴分词作为分词工具。

结巴分词~\cite{Jieba}是一个基于Python语言开发的开放源代码的中文分词工具，其由百度(Baidu Inc.)的Sun Junyi开发并发布在Github上，其目标是“做最好的Python中文分词组件”。结巴分词自从2012年10月7日被发布到pypi以来不断地被改进和完善，目前已经发布的最新版本为0.32。其所采用的算法如下所示：

\begin{enumerate}
\item 基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG)。

\item 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合。

\item 对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法。
\end{enumerate}

总得看来，结巴分词之所以能够被广泛关注和使用，主要是因为其具有以下特点：

\begin{enumerate}
\item 安装简单。用户可以直接通过“easy\_install jieba”或者“pip install jieba”进行安装，就行安装普通的Python 包一样。

\item 使用简单。用户只需使用一句代码即可实现分词操作，如用户通过如下代码即可将句子“南京市长江三桥”分词若干词汇序列并将词汇保存到列表中。

\begin{verbatim}
seg_list = jieba.cut("南京市长江三桥")；
\end{verbatim}


\item 支持多种分词模式。结巴分词支持三种分词模式，即精确模式、全模式和搜索引擎模式。其中，精确模式试图将句子最精确地切开，适合文本分析；全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。

\item 支持多种操作。除了基本的分词之外，结巴分词还支持添加自定义词典、关键词提取、词性标注、并行分词、繁体分词以及Tokenize等功能。

\item 支持多语言。除了最基础的Python语言版本外，目前结巴分词还支持Java、C++以及Node.js三种语言且源码均已发布到Github上。
\end{enumerate}

\subsection{Gensim软件包}

为了得到每一首歌曲在隐含主题上的概率分布，我们使用以LDA为代表的主题模型分析方法对每首歌曲对应的文档进行分析，这里的文档是由用户为歌曲标记的标签构成。LingPipe~\cite{LingPipe} 和Mallet~\cite{Mallet}都是非常优秀的自然语言处理软件包，但考虑到它们比较复杂且对LDA的实现欠佳，我们选择使用另一个优秀的软件包Gensim~\cite{Gensim}。Gensim 最初是作为一组被用在捷克数学文献存取网站dml.cz中的Python脚本的集合而出现，而其功能只是简单地根据给定的文档来生成一组近似的文档，Gensim正是“Generate Similar”的简称。为了使用隐含语义的方法对文档分析，作者于2010年将其扩展为一个Python包，随后作者于2011年开始使用Github来管理源代码并于2013年设计了Gensim独特的Logo和网站。Gensim 可以非常方便地实现主题模型，正如其介绍中所说―“为人类而设计的主题模型开发包”，其主要具有以下特点：

\begin{enumerate}
\item 可扩展性。Gensim通过使用增量式的在线训练方法可以处理大规模的语料库，从而不需要将所有语料一次性装入内存，降低了内存的负担，增强了可扩展性。

\item 平台无关性。Gensim是纯Python实现，可以运行在Linux、Windows、OS X以及其他支持Python和Numpy的平台上。

\item 鲁棒性。Gensim已经被很多个人和组织应用在各种系统中超过四年，早已过了一个开源项目的“妈妈，我发布了一个脚本”的初始阶段。

\item 开源性。Gensim开放源代码，其使用GNU LGPL许可证，允许个人和商业机构使用和修改该项目。

\item 高效性。Gensim中的各种算法都是使用经过优化的方法进行实现的，使得算法的效率较高；另外，Gensim实现了一些算法的分布式版本，使得算法可以并行执行或者在集群上执行，进一步增加算法的执行效率。

\item Gensim包含对一些常用数据格式的高效内存实现方式，同时支持不同数据格式之间的转换。

\item Gensim除了可以快速地执行主题模型建模，还提供了快速计算文档相似性的方法。
\end{enumerate}
　　　
下面简单介绍以下使用Gensim软件包进行LDA建模的方法和流程：

\begin{enumerate}
\item 准备语料库，这里就是需要进行主题模型建模的文档集合。

\item 对文档集合中的每一篇文档进行分词并利用分词的结果构造词典，同时可以得到每个词或者词组在词典中的编号。

\item 词典生成好之后就生成语料库，语料库中的每一个语料与文档集合中的每一篇文档一一对应，而语料的表示形式即是文档的向量空间模型，即词典中的某个词或词组在该文档中出现的次数。

\item 将上述向量空间模型表示的语料库转换成TF-IDF模型表示的语料库，即此时得到的语料库可以表征每一个词或者词组的重要程度。

\item 进行LDA主题模型建模，得到建模结果。
\end{enumerate}

\section{在线处理模块}

\subsection{序列生成}

用户在当前会话期内收听的歌曲序列是本文所述方法和框架的输入，本节将介绍序列生成系统是如何根据用户的行为生成这种序列的。需要强调的是，作为输入的序列是用户产生积极行为的歌曲序列，下面将给出对于积极行为的定义。

用户在收听一首歌曲的时候，可能对其产生两种典型的行为，即积极行为和消极行为。典型的积极行为包括用户收藏当前歌曲、分享当前歌曲、完整收听或者收听当前歌曲的绝大部分等，而典型的消极行为包括用户将歌曲丢进“垃圾桶”、选择跳过当前歌曲、只收听当前歌曲的一小部分等。对于收藏、分享、丢进“垃圾桶”、跳过这些比较直观地行为我们不再做进一步描述，而对于用户收听歌曲比例所表达的态度，本文认为如果用户收听当前歌曲的长度超过了歌曲总长度的50\%那么用户喜欢该歌曲，否则认为用户不喜欢当前歌曲，即消极行为，如式5.1和5.2所示。其中，\emph{total\_length}表示歌曲的总长度，\emph{past\_length}表示用户收听该歌曲的时间长度，而\emph{pastRatio}表示用户收听长度占歌曲总长度的比例。\emph{attitude}表示用户对歌曲的态度，当\emph{pastRatio}不小于50\%时取值为1表示积极态度，否则表示消极态度。假如歌曲“大海”(记为\emph{s})总长度为4分40秒，即280000毫秒，用户\emph{a}收听至1分钟即60000毫秒时跳过，那么对应的有\(pastRatio(a,s)=21.43\%\)，那么我们认为用户\emph{a}不太喜欢歌曲“大海”，而用户\emph{b}收听至4分钟即240000毫秒时跳过，那么对应的有\(pastRatio(b,s)=85.71\%\)，我们认为用户\emph{b}比较喜欢当前歌曲。至于\emph{b}为什么没有听完整首歌曲，即\( pastRatio(b,s)\neq{100\%}\)，可以认为是用户\emph{b}收听歌曲的时间过长，想要换一首以免疲劳，而仍然收听了过半歌曲说明他还是喜欢此首歌曲的。序列生成系统在歌曲播放至50\% 时便读取数据库中保存的用户当前会话期内的积极歌曲序列，并结合当前歌曲组成新的序列传递给推荐引擎。

\begin{equation}
pastRatio(user,song)=\frac{past\_length}{total\_length}\times{100\%}
\end{equation}

\begin{equation}
attitude(user,song)=
\left\{
\begin{aligned}
1    ,pastRatio(user,song)\ge{50\%} \\
0    ,pastRatio(user,song)<50\%
\end{aligned}
\right.
\end{equation}

\subsection{推荐引擎}

在由序列生成系统得到用户当前会话期的收听列表后，图5.2所述的系统框架则激活基于Storm框架的多维时序推荐引擎去读取列表进行处理并生成最终的推荐列表。之所以使用Storm框架是因为音乐推荐系统是一个对实时性要求比较高的系统，需要及时地为用户生成推荐结果，而Storm恰恰是这样一个开源的且面向实时性处理的分布式框架。第二章中已经简单介绍了Storm基本组成以及对应的DRPC的基本内容，本节将介绍该框架在本文原型系统中的应用。由前文可知，在Storm框架中，每一个分布式的计算任务都被称之为一个拓扑，而拓扑按照一定的拓扑结构实现的。因此，本文系统原型中核心的推荐引擎模块也对应着一个拓扑任务，用以完成为用户实时生成推荐列表的工作，其对应的拓扑图如图5.5所示。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/topology.eps}
\caption{推荐引擎工作拓扑结构图}
\label{fig_topology}
\end{center}
\end{figure}

\begin{enumerate}
\item 推荐引擎通过数据库接口DAO从数据库中读取用户当前会话期内的歌曲列表。

\item 读取共享内存中每一首歌曲隶属于每一个隐含主题的概率，进而将1中的序列分割成\emph{K}个子时间序列。其中，每一个子时间序列对应一个隐含主题，序列对应的变量为歌曲在该主题上的隶属概率。

\item 对2中的\emph{K}个子时间序列进行时序预测，预测下一期的取值，即用户可能收听的歌曲在该主题上的隶属度。

\item 将\emph{K}个主题上的预测值汇总，得到下一首歌曲的完整概率分布。

\item 计算曲库内所有歌曲与该歌曲的相似度。

\item 将5中的相似度按照由大到小的顺序排列，并取前10作为推荐列表。

\item 将推荐列表返回。
\end{enumerate}

由图5.5可以非常直观地看出，本文所实现的多维时序推荐引擎是完全并行化的，即各个子时间序列的分析与预测以及不同歌曲与目标歌曲之间相似度的计算都是可以并行执行的，这显然能够提升系统的执行效率。至于在并行化的时候选择多少并行结点，这个取决于具体的应用场景，本文所研究的多维时间序列分析方法由于存在\emph{K}个隐含主题，因此自然选择\emph{K}个并行结点。当然，能够并行的原因是我们弱化了各个隐含主题之间的相关性，认为各个隐含主题之间是相互独立的。

在构建了上述拓扑结构并实现后，下面需要做的就是将其部署到服务器上，具体的部署过程如下所示。

\begin{enumerate}
\item 启动zookeeper：zkServer.sh start。Zookeeper 分布式服务框架主要是用来解决分布式应用中经常遇到的一些数据管理问题，如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。Nimbus和Supervisor节点之间所有的协调工作是通过Zookeeper 集群来实现的。
\item 启动nimbus：storm nimbus。主控节点（Master Node）上运行一个被称为Nimbus的后台程序，它负责在Storm集群内分发代码，分配任务给工作机器，并且负责监控集群运行状态。Nimbus 的作用类似于Hadoop中JobTracker的角色。
\item 启动supervisor：storm supervisor。每个工作节点（Work Node）上运行一个被称为Supervisor的后台程序。Supervisor负责监听从Nimbus分配给它执行的任务，据此启动或停止执行任务的工作进程。每一个工作进程执行一个Topology的子集；一个运行中的Topology由分布在不同工作节点上的多个工作进程组成。
\item 启动UI：storm ui。storm UI是一个可以查看storm运行状态的的一个网站，可以查看Topology的执行状态。
\item 启动drpc：storm drpc。通过DRPC，其他机器可以远程执行Topology。
\item 提交topology：storm jar SweetFM.jar com.wst.sweetfm.topology.DRPC\_MTSATopology sweetfm。将实现好的Topology提交至Storm集群进行执行。
\item 显示所有topology：storm list。将所有的计算任务以列表的形式展现出来。
\item 杀死指定topology：storm kill sweetfm。
\end{enumerate}

mithunsatheesh给出了一种使用PHP远程调用Storm集群中运行的Topology的方法，如下表所示。

include "includes/drpc/DRPC.php";

\$drpc = new DRPC("xxx.xxx.x.xx",3772,NULL);

\$result = \$drpc-\(\textgreater\)execute("CallFunctionName",\$params);

具体到我们的原型系统中即是：

include "includes/drpc/DRPC.php";

\$drpc = new DRPC("114.212.84.238",3772,NULL);

\$seq = “4,6,1,8,2,0”;

\$result = \$drpc-\(\textgreater\)execute("sweetfm",\$seq);

首先构造一个drpc对象，然后以适当的格式给出用户在当前会话期的歌曲序列并作为参数传递给drpc对象的execute函数，Storm集群上的sweetfm接收传递过来的参数并进行计算，
计算结束之后将结果返回给result，即一个歌曲推荐列表，如”[1,2,3,4,5,6,7,8,9,10]”

\section{系统效果}

本节给出本文实现的系统原型的效果截图，如下所示。在下图中，从左上到右下共有六张效果图，分别为游客登录效果图、用户注册效果图、用户登录效果图、
系统主界面效果图、用户对歌曲打标签效果图以及用户调整播放音量效果图。

\begin{figure}[!h]
\begin{center}
\includegraphics [width=0.75\textwidth]{figures/sweetfm.eps}
\caption{原型系统效果图}
\label{fig_sweetfm}
\end{center}
\end{figure}

\chapter{总结与展望}
\label{C:conclusion}

\section{工作总结}

近年来，个性化音乐电台应用大量出现，但这些应用的音乐推荐算法要么没有考虑用户听歌行为与所处上下文环境之间的关系，要么对用户行为时间相关性处理地不够合理，导致推荐的结果
不够理想。为了提升音乐推荐的效果，本文提出了一种基于多维时间序列分析的音乐推荐方法，较为合理地利用了用户中期行为。进一步地，本文给出一种基于用户长期、中期和即时行为的
综合音乐推荐方法，全面考察了用户行为的时间相关性。通过实验和原型系统的实现，本文初步验证了所述方法的有效性和可行性。本文的主要贡献如下所示：

1. 提出了一种基于多维时间序列分析的个性化音乐推荐方法，该方法在使用主题模型将歌曲表示成由若干隐含主题构成的概率分布的基础上将用户在当前会话期内的行为建模为一个多
维时间序列。通过对该多维时间序列的分析，该方法能够较好地预测用户行为偏好，并给出合理的推荐结果。

2. 给出了一种基于用户长期、中期和即时行为的综合音乐推荐方法，综合考虑了用户长期行为、中期行为以及即时行为对用户未来行为的作用和贡献。

3. 基于上述方法实现了一个原型系统，并通过Storm实现了上述方法的并行化，提高了处理效率。

\section{工作展望}

\begin{enumerate}
\item 本文只是使用用户对歌曲所打的标签去构造歌曲对应的文档，可以尝试使用更丰富的的文本信息表征歌曲，进而构造更符合歌曲内在特征的文档。

\item 本文所述方法主要是对用户的积极行为进行分析，可以尝试加入一些用户的否定行为信息。
　　　
\item 本文工作任务不同隐含主题之间是相互独立的，可以进一步考察不同主题之间的相关关系，提升分析的准确性。
\end{enumerate}

  % 附录
\appendix

\chapter{数据集使用说明}
\label{C:dataset}

\section{权利声明}

本数据集抓取自Lastfm，所有数据归Lastfm所有，禁止商业用途。
如果您想使用该数据集进行科研活动，请务必给出对Last.fm及本文的引用信息。

\section{数据特点}

\begin{enumerate}
\item 包含完整的用户、歌曲、曲作者的基本信息。

\item 包含丰富的用户行为记录，可用于构造用户行为序列。

\item 包含歌曲、曲作者的显著标签信息，可用于从文本的角度描述歌曲和作者。

\item 提供了标签的基本信息。

\item 数据被随机分组，可直接用来实验。
\end{enumerate}

\section{组织形式}

本数据集使用Mysql进行管理，对应的数据库名为lastfm，您可以非常容易地将其导入并使用。数据集包含有5个基本的数据表：

\begin{enumerate}
\item 记录表record用于记录用户的收听行为，如某用户在某时间段收听了某歌曲。record由记录标识符(rid:int)、用户标识符(uid:varchar)、歌曲mbid(mbid:varchar)、记录发生的unix时间戳(uts:varchar)、记录发生的日期时间(datetime:varchar)、记录所属分组(scale:int)等字段构成。

\item 用户表user用于记录用户的基本信息，其由用户标识符(uid:varchar)、用户名(username:varchar)、用户国籍(country:varchar)、用户年龄(age:varchar)、 用户性别(gender:varchar)、用户注册时的unix时间戳(registeredTime:varchar)、 用户注册日期时间(registeredText:varchar)、播放序列(playlist:text)、 用户所属分组(scale:int)等字段构成。

\item 歌曲表song用于记录歌曲的基本信息，其由歌曲标识符(sid:varchar)、歌曲对应mbid（mbid:varchar）、歌曲名称(name:text)、 歌曲时长(duration:varchar)、曲作者标识符(aid:varchar)、曲作者名称(aname:varchar)、专辑名(album:text)、听众数目(listeners:varchar)、播放次数(playcount:varchar)、描述歌曲的显著标签(toptag:text)等字段构成。

\item 曲作者表artist用于记录曲作者的基本信息，其由曲作者标识符(mbid:varchar)、曲作者名称(name:text)、曲作者图片的链接(img:text)和描述曲作者的显著标签(toptag:text) 构成。

\item 标签表tag用于记录标签的基本信息，其由标签标识符(id:varchar)、标签名称（name:text）、标签被创建的次数(reach:varchar)、标签被使用的次数(taggings:text)等字段构成。
\end{enumerate}

\section{字段解析}


\subsection{scale}

记录表record和用户user中的scale字段用以表征记录和用户所处的分组编号。为了方便，本数据集将用户记录和用户分为Unused、Small、Whole 和Session四类。

其中，Small、Whole和Session被scale字段分割成40组，其中第0组到第9组属于Small数据集，第0组到第29 组属于Whole数据集，第30组到第39组属于Session数据集。Unused数据的scale设为-1。显然，Small数据集是Whole数据集的一部分，它们的特点是每一个用户所收听的歌曲都在一个会话期内，即不存在长时中断。从Whole数据集中划分出Small数据集的主要目的是方便机器性能不佳的用户使用，对于Small数据集，用户可以使用10组中的9组作训练集而余下的一组作测试集。Session 数据集与Whole数据集的主要区别是每一个用户所收听的歌曲至少在两个会话期内。类似的，用户可以用其中9组作训练集而余下的一组作测试集。下表给出了Small、Whole和Session三类数据集的基本统计信息。
\begin{table}[!hbp]
\caption{数据集LastfmSeq的统计信息}
\centering
\begin{tabular}{|c|c|c|c|}
\hline
 & Small & Whole & Session \\
\hline
 用户数 & 1530 & 4590 & 1690 \\
\hline
 歌曲数 & 24992 & 62422 & 32218 \\
\hline
 稀疏度 & 99.92 & 99.97 & 99.92 \\
\hline
 最大长度 & 30 & 30 & 66 \\
\hline
 最短长度 & 10 & 10 & 20 \\
\hline
 中位长度 & 24 & 24 & 30 \\
\hline
\end{tabular}
\end{table}

\subsection{playlist}

数据表user中的playlist字段用以表征用户按序收听的歌曲构成的序列，数据如“sid1:ratio1==>sid2:ratio2==>...==>sidn:ration”所示。其中，sid表示被听歌曲的标识符(注:非mbid)。ratio 表示两首歌之间的时间间隔与前一首歌曲时长的比例，用以表征用户收听该首歌曲的时长比例。显然，ratio 过小表示用户刚开始收听遍跳过，ratio过大表明歌曲被完整收听而且还可能有暂停发生。

\subsection{toptag}

数据表song和artist中的字段toptag表示Lastfm网站中的用户给歌曲或曲作者所打的显著标签，数据如“{tag1:count1,tag2:count2,...,tagn:countn}”所示。其中，tag 表示被打标签名称，count表示标签被标记次数。需要注意的是，在Lastfm中，count并非标签被应用于歌曲或曲作者的绝对次数，而是标签相对于被使用最多次的标签的相对次数。例如在描述歌曲“Collapse of History”的标签中，“industrial”被使用最多次且次数为200，而标签“Stars”被使用100 次。那么，在歌曲记录对应的字段toptag中，“industrial” 对应的count为100，“Stars”对应的count为50，即{“industrial”:100,”starts”:50}，以此类推。

\subsection{其他字段}

数据表中的其他字段都比较简单直观，这里就不再一一介绍。

\section{应用场景}

\begin{enumerate}
\item 使用文本分析的方法描述歌曲或者曲作者特征。
\item 分析用户所收听歌曲的序列，包括跨会话分析和会话内分析。
\item 预测用户下一首可能收听的歌曲或者曲作者。
\item 生成用户可能喜欢的播放列表。
\item 标签预测问题。
\item 其他适合的应用场景。
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 附件部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter

% 参考文献
% 使用 BibTeX，不使用 BibTeX 时注释掉下面一句。
\bibliography{template}

% 不使用 BibTeX
%\begin{thebibliography}{2}
%
%\bibitem{deng:01a}
%{邓建松,~彭冉冉,~陈长松}.
%\newblock {\em \LaTeXe{}~科技排版指南}.
%\newblock 科学出版社,~书号:~7-03-009239-2/TP.1516, 北京, 2001.
%
%\bibitem{wang:00a}
%王磊.
%\newblock {\em \LaTeXe{}~插图指南}.
%\newblock 2000.
%\end{thebibliography}

% 本章可以删去
\Nchapter{简历与科研成果}

\noindent {\heiti 基本情况}
\vspace{1ex}

\noindent 王守涛，男，汉族，1987~年~12~月出生，安徽省阜阳市人。

\vspace{2ex}
\noindent {\heiti 教育背景}

\begin{description}[labelindent=0em, leftmargin=8em, style=sameline]

\item[2011.9～2014.6] 南京大学计算机科学与技术系 \hfill 硕士

\item[2007.9～2011.6] 合肥工业大学计算机信息学院 \hfill 本科

\end{description}

% 发表文章目录
\vspace{5ex}
\begin{Publications}{2}

\item 吕建,徐锋,王守涛. 一种基于多维时间序列分析的个性化音乐推荐系统及其实现方法:中国. 201410077177.1[P]. 2014-03-04.

\end{Publications}

  % 致谢
\begin{thanks}
\vskip 18pt

日光荏苒，在南京大学计算机与技术系软件所攻读硕士的三年行将结束，在此对在我成长道路上谆谆教导的师长以及在我生活中给予关心和帮助的同学表达由衷的谢意。

首先，感谢我的导师徐锋教授，从起始移动互联网领域的编程实践到后来推荐系统相关知识的学习与研究，徐老师都耐心地进行指导。在我工作遇到困难的时候，徐老师总是能够给出一些非常有建设性并且有远见的建议，他总是能够从比较高的层次指出工作中存在的不足，这对于我从宏观上去把握所研究的工作内容有非常大的裨益。

感谢计算机系软件所的吕建教授，陶先平教授，马晓星教授，胡昊教授，黄宇副教授，许畅副教授，曹春副教授，余萍，马俊和张建莹老师等，他们在我学习和工作中给予了许多帮助。感谢和我一起努力的同学，姚远博士，张栋栋，王瑶菁，袁明珠，周昊一，陈晓宇等，在论文和项目中的鼓励和协作。感谢徐经纬博士，朱晓瑞博士在相关工作中给出的启发性见解和指导。感谢室友王海涛，王逸恺等，让我对其他研究方向有所认知，他们科研的态度也给了我很大启发，而平时和谐愉悦的宿舍生活使得我在平时的科研和学习中充满活力，这定将成为我学生生活中最美好的记忆之一。

感谢父母一直以来对我的支持和鼓励，他们为了给我创造良好的成长环境和学习环境付出了很大的心血，他们是我坚实的后盾和持续奋斗的动力，我定不辜负他们对我的期望，在以后的工作中继续努力，成就自己的一番事业。

最后，感谢我的女朋友侯小丽的坚守和付出，无论我遇到何种挫折和坎坷，她都出现在我的身边并给予我最大的支持和鼓励，我一定会持续积极上进，为以后的更加美好的生活创造条件。

\end{thanks}


\end{document}
