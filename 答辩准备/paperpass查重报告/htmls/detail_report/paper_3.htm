<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_11.htm">尾页</a>
页码：3/11页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">69</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/199.htm' target='right' class='orange' >其中，T代表测试集，u和i表示测试集中的用户和物品，rui是用户u对物品i的实际评分，而r^ui是推荐算法给出的预测评分。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">70</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/200.htm' target='right' class='orange' >MAE采用绝对值计算预测误差，如公式2.10所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">71</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/201.htm' target='right' class='orange' >预测误差越小，预测准确度越高，推荐算法的效果越好。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">72</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/202.htm' target='right' class='red' >Top-N推荐一般通过准确率(precision)和召回率(recall)来度量算法的优劣。</a><a href='../sentence_detail/203.htm' target='right' class='red' >设R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T (u)是用户在测试集上的行为列表 [40]。</a><a href='../sentence_detail/204.htm' target='right' class='orange' >那么，推荐结果的准确率和召回率如公式2.11和2.12所示。</a><a href='../sentence_detail/205.htm' target='right' class='orange' >命中率和准确率越大，预测准确度越高，推荐算法的效果越好。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">73</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.3.3其他评测指标</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">74</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>除了预测准确度这一重要指标之外，推荐系统的评测还有诸如覆盖率、多样性等指标，这些指标从不同的角度看待推荐的有效性。</span><a href='../sentence_detail/208.htm' target='right' class='orange' >覆盖率越大，说明系统所能推荐的物品越广泛，也说明系统挖掘物品长尾的能力越强。</a><span class='green'>多样</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">75</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/210.htm' target='right' class='orange' >性(Diversity)用来描述推荐列表中物品两两之间的不相似性，列表中物品两两之间的相似性越小表示推荐的多样性越大。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">76</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>考虑到用户满意度无法进行离线实验而覆盖率、多样性等对推荐算法的表征能力不佳，本文主要使用预测准确度来评估所给出的音乐推荐方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">77</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4分布式实时计算系统</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">78</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>尽管目前单机的处理能力已经得到了极大提升，但其在应对大数据时代产生的海量数据时仍然非常吃力。</span><a href='../sentence_detail/214.htm' target='right' class='orange' >为了解决大数据时代海量数据的处理和分析的问题， Google提出了一种分布式计算模型，即 MapReduce，</a><span class='green'>该模型使得由一般能力机器组成的集群可以完成大规模或者超大规模的计算工作。</span><span class='green'>在Google工作的启发下，Apache于2005年开发了分布式应计算框架Hadoop[16]。</span><span class='green'>Hadoop对于批处理的工作以及离线的海量数据分析比较有优势，但其在面对一些实时性要求比较高的计算任务时，处理能力略显欠缺。</span><span class='green'>为了弥补这一缺憾，以Storm[50]为代表的分布式实时计算系统被开发了出来，这些系统及框架在实时数据流分析方面能够取得比Hadoop更好的效率和效果。</span><span class='green'>其中，Storm是由Twitter开发的一款开源的分布式实时计算框架，其适用于流数据处理和分布式远程过程调用两种场景。</span><span class='green'>Storm的处理组件是分布式的且处理延迟极低，使得其在分布式远程过程调用的场景中也能够得到比较充分的应用。</span><span class='green'>本文所要解决的问题恰恰是一个实时数据流的分析问题，因此本文后面将会选用 Storm进行数据的分析和处理，</span><span class='green'>本节对其基本组成及其在分布式远程过程调用中的应用进行介绍。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">79</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4.1基本组成</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">80</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/224.htm' target='right' class='orange' >一个Storm集群往往是由一个主控节点(Master Node)以及一定数目的工作节点(Work Node)组成。</a><span class='green'>其中，Master Node上运行着一个“Nimbus”进程，而每个Work Node运行着一个“Supervisor”进程。</span><span class='green'>在Storm中，一个实时应用的计算任务被打包成一个Topology任务发布，且Topology任务一旦提交后永远不会结束，除非用户显式地去停止任务。</span><span class='green'>计算任务Topology是由多个Spout和Bolt计算组件构成，这些计算组件是通过数据流连接起来的。</span><a href='../sentence_detail/228.htm' target='right' class='orange' >其中，Spout是Storm中的消息源，用于生产消息，Bolt是Storm中的消息处理者，用于消息的处理。</a><a href='../sentence_detail/229.htm' target='right' class='red' > Topology中每一个计算组件都有一个并行 执行度，在创建Topology时可以进行指定，Storm会在集群内分配对应并行度个数的线程来同时执行这一组件。</a><span class='green'>图2.1是Twitter Storm官方给出的一个典</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">81</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>型 Topology示意图，其中水龙头表示用以生产数据的 Spout组件，闪电表示用户处理数据 Bolt组件，</span><a href='../sentence_detail/232.htm' target='right' class='orange' >消息或数据由 Spout组件产生后便在不同的 Bolt组件中进行流动并被处理。</a><span class='green'>Storm的编程非常简单，用户只需要在 Spout组件中实现数据读取及分割的逻辑，在 Bolt组件中实现数据的处理逻辑，</span><span class='green'>同时在各组件中指定数据流动方式即可轻松地完成并发布一个实时计算的任务。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">82</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图 2.1:</span><span class='green'>典型Twitter Storm示意图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">83</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4.2分布式远程过程调用</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">84</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>分布式远程过程调用（ Distributed Remote Procedure Call， DRPC）是联系客户端与 Storm集群的一种机制，</span><span class='green'>Storm中引入这一机制的主要目的是利用 Storm的实时计算能力来并行化 CPU密集型计算。</span><span class='green'>其中，DRPC通过是DRPC Server实现的，其整体工作过程如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">85</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.接收到一个RPC调用请求；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">86</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.发送请求到Storm上的拓扑；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">87</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.从Storm上接收计算结果；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">88</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/244.htm' target='right' class='orange' >4.把计算的结果回传到客户端上。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">89</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2.2更为细致地描述了DRPC的工作流程，大致可以分为如下五个步骤：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">90</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/246.htm' target='right' class='orange' >1. 客户端向服务器发送函数的名称及参数选项；</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">91</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.</span><span class='green'>Storm上的Topology通过DRPCSpout实现这一函数，从DPRC Server接收到函数调用流；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">92</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3. 服务器会为每次调用生成一个确定的标识符；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">93</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4. 集群上运行的拓扑任务开始计算，最后连接到服务器并把结果发送给指定标识符；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">94</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5. 服务器通过使用标识符，将结果关联到对应的客户端，将计算结果回传给客户端。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">95</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图 2.2:</span><span class='green'>DRPC工作流程示意图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">96</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.5文本建模</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">97</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了对歌曲进行全面地刻画，本文将使用文本分析的方法对歌曲进行建模，本节介绍一些常用的文本建模方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">98</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.5.1向量空间模型</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">99</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>计算机不具备人脑的结构，无法理解自然语言，所以需要首先将无结构的自然语言文本转化为计算机可计算的特征文本。</span><span class='green'>为此，Salton等人在20世纪70年代提出了向量空间模型(Vector Space Model， VSM)[45]。</span><span class='green'>向量空间模型首先将每一个文档看做一个词袋(Bag ofWords)，即认为一篇文档是由一组词构成的一个集合且词与词之间没有顺序以及先后的关系。</span><a href='../sentence_detail/260.htm' target='right' class='orange' >其次，向量空间模型将文档表示成一个向量，向量的每一维表示一个词项，而每一维的取值表示该词项在文档中的权重。</a><a href='../sentence_detail/261.htm' target='right' class='orange' >对于文档集合 D中编号为 j的文档 dj，可以将之表示成一个 t维的向</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">100</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>量d.j =(ω1;</span><span class='green'>j， ...， ωt;</span><span class='green'>j)，其中 t表示词项的数目， ωi;</span><span class='green'>j(1 ≤ i ≤ t)表示第 i个词项在文</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">101</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>档dj中的权重。</span><span class='green'>在对文本进行建模的过程中，词的选取及权重的计算有以下几种典型方式：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">102</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.布尔模型。</span><a href='../sentence_detail/269.htm' target='right' class='orange' >这是最为简单直观的一种计算词项权重的方法，其将词项在文档中是否出现作为其权重，如果词项在文档中出现那么将其权重记为 1，否则记为 0。</a><a href='../sentence_detail/270.htm' target='right' class='orange' >虽然这种方法比较简单，但是它没有体现词语在文档中出现的频率。</a><span class='green'>一般来讲，词语在文档中出现的越多，说明它对该篇文档的重要性越大（“的”、“得”、“地”、“是”等停用词除外）。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">103</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.词频模型。</span><a href='../sentence_detail/273.htm' target='right' class='orange' >与布尔模型不同的是，词频 (Term Frequency， TF)模型统计词项在文档中出现的次数，然后得到词项的频率，并将之作为词项的权重。</a><a href='../sentence_detail/274.htm' target='right' class='orange' >词项ti相对于文档dj的词频如式2.13所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">104</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>这里 ，ni;</span><a href='../sentence_detail/276.htm' target='right' class='orange' >j表示该文档中出现该关键词的频次。</a><span class='green'>词频模型突出了词频对词项重要性的影响，能够取得比布尔模型较好的效果。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">105</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>词频-逆文本频率模型。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">106</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/279.htm' target='right' class='orange' >词频-逆文本频率( Term Frequency- Inverse Document Frequency， TF- IDF)是对 TF模型的补充，其认为词项的重要性随着其在特定文档中出现次数的增加而增强，</a><a href='../sentence_detail/280.htm' target='right' class='orange' >但同时随着其在全体文本中出现次数的增加而减弱。</a><span class='green'>词项ti相对于文档dj的TF-IDF取值如式2.14所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">107</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/282.htm' target='right' class='orange' >idfi为逆向文本频率，定义如式 2.15所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">108</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/283.htm' target='right' class='orange' >其中， |D|表示文档集合中的文档总数， |{j :</a><a href='../sentence_detail/284.htm' target='right' class='orange' > ti ∈ dj}|表示文档集合中包含词项 ti的文档数目。</a><span class='green'>TF-IDF结构简单，容易理解，被广泛应用。</span><span class='green'>但是，其 无法准确捕捉文档内部与文档间的统计特征，也不能解决同义词和多义词的问题，因此精确度不是很高。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">109</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.5.2 LDA模型</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">110</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/288.htm' target='right' class='orange' >为了解决同义词和多义词的问题，Blei等人于2003年提出了隐含狄利克雷分配模型(Latent Dirichlet Allocation，LDA)[6][21]。</a><span class='green'>LDA也是一种典型的词袋模型，其认为一篇文档由多个主题构成，而文档中每一个词都是由对应的主题生成而来。</span><span class='green'>其中，主题在一定程度上就是一个类别，该类别里有若干代表性的词项。</span><a href='../sentence_detail/291.htm' target='right' class='orange' >形象来说，主题就是一个桶，里面装了出现概率较高的单词而这些单词与这个主题有很强的相关性。</a><a href='../sentence_detail/292.htm' target='right' class='orange' >这样，LDA模型便通过隐含主题将文本与词项联系起来，从而达到降维的目的。</a><a href='../sentence_detail/293.htm' target='right' class='orange' >LDA是一种生成模型，一篇文档按照如下所示的规则生成：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">111</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.假设有两种类型的桶，一种是文档-主题桶，桶里的每一个球代表一个主题；</span><span class='green'>另一种桶是主题-词汇桶，桶中的每一个球代表一个词汇。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">112</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.文档的生成过程就是不断从桶中取球的过程，每一次先从文档-主题桶中取出球，得到该球代表的主题编号z。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_2.htm">上一页</a>
<a class="pagelink" href="paper_4.htm">下一页</a>
<a class="pagelink" href="paper_11.htm">尾页</a>
页码：3/11页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
