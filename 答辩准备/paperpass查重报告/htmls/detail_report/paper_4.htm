<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威中文论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>

<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_11.htm">尾页</a>
页码：4/11页
]
</div>

<br><div style="margin-left:25px">

<img src="../../images/guanwang.gif"></div><br><br>
<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">113</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.从编号为z的主题-词汇桶中取球，得到一个词汇。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">114</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.不断重复2，3两步，即可生成一篇文档。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">115</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/299.htm' target='right' class='orange' >在LDA模型中，记文档-主题的概率分布为多项式分布.θ，主题-词汇的概率分布为多项式分布φ.。</a><span class='green'>LDA模型认为.θ和φ.是模型中的参数，而考虑到参数都是多项式分布，模型选择狄利克雷分布作为其先验分布。</span><span class='green'>在确定了这些分布之后， LDA下面需要做的就是估计这些分布的参数，如算法1所示的吉布斯采样(Gibbs Sampling)是目前比较流行的估计参数的方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">116</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在本文后续实验中，我们将分别以 TF- IDF为代表的向量空间模型和以 LDA为代表的主题模型对歌曲对应的文档进行建模，</span><span class='green'>发现 LDA能够获得较高的推荐准确率，因此我们将 LDA作为我们主要的文本建模方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">117</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.6时间序列预测</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">118</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>歌曲时间短、消费代价低的特点决定了其能够较容易地形成序列，且这种序列是有严格的时间顺序的。</span><span class='green'>本文将通过对用户在当前会话期内所听歌曲形成的时间序列的分析来预测用户接下来的行为。</span><a href='../sentence_detail/307.htm' target='right' class='orange' >本节将简单介绍一些常用的时间序列预测方法。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">119</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Algorithm 1</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">120</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>LDA模型的Gibbs采样算法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">121</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1:</span><a href='../sentence_detail/311.htm' target='right' class='orange' > 首先对所有文档中的所有词遍历一遍，为其都随机分配一个主题，即zm;</a><a href='../sentence_detail/312.htm' target='right' class='orange' > n= k～ Mult(1/ K)，其中第 m篇文档用 m表示，文档中的第 n个词用 n表示，</a><span class='green'>k表示主题， K表示主题的总数，之后将 nkm、 nm、 ntk、 nk都加1，</span><a href='../sentence_detail/314.htm' target='right' class='orange' >它们分别表示在第 m篇文档中主题 k出现的次数、第 m篇文档中主题数量的和、主题 k对应的词 t的次数，</a><span class='green'>k主题对应的总词数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">122</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2:</span><span class='green'>遍历第1篇文档中的所有词，假如词项 t对应主题为 k，则将 nkm、 nm、 ntk、 nk都减1，</span><span class='green'>即先拿出当前词，之后根据式2.16取样出新的主题，再将 nkm、 nm、 ntk、 nk都加1。</span><span class='green'>其中，α和β为对应的Dirichlet分布的参数，V为词汇总数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">123</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3:</span><span class='green'>重复步骤2直至遍历所有文档。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">124</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4:</span><span class='green'>输出LDA模型中的参数.θ和φ.。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">125</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.6.1简单平均法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">126</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/325.htm' target='right' class='orange' >简单平均法直观上就是使用变量的历史平均值作为变量的下一期取值，按照采用的平均方法又可以分为算术平均法、加权平均法和几何平均法三类。</a><a href='../sentence_detail/326.htm' target='right' class='orange' >其中，算术平均法以观察变量的算术平均数作为下期预测值，加权平均法以观察变量的加权算术平均数作为下期的预测值，</a><a href='../sentence_detail/327.htm' target='right' class='orange' >而几何平均法是以观察变量的几何平均数作为下期的预测值。</a><a href='../sentence_detail/328.htm' target='right' class='orange' >简单平均法比较简单、直观，但其预测误差一般偏高。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">127</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/329.htm' target='right' class='orange' >2.6.3差分整合移动平均自回归模型</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">128</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>差分整合移动平均自回归模型( Autoregressive Integrated Moving Average model， ARIMA)又称为 Box- Jenkins方法，是由 Box和 Jenkins于1970年提出的一种时间序列预测方法，</span><span class='green'>目前已经得到广泛的应用[31]。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">129</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/332.htm' target='right' class='red' >在模型ARIMA(p，d，q)中，“AR”表示自回归模型，p为自回归阶数；</a><a href='../sentence_detail/333.htm' target='right' class='orange' >“MA”表示滑动平均模型，q表示滑动平均的阶数；</a><a href='../sentence_detail/334.htm' target='right' class='orange' >d表示将时间序列转化为平稳时间序列所作的差分次数，即差分阶数。</a><a href='../sentence_detail/335.htm' target='right' class='orange' >ARIMA首先需要进行d次差分从而将非平稳序列转化为平稳序列，然后利用自回归模型和滑动平均模型对转换后的平稳序列进行预测。</a><a href='../sentence_detail/336.htm' target='right' class='orange' >进一步地，模型ARIMA(p，d，q)可以表示成如下三个式子。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">130</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/337.htm' target='right' class='orange' >其中，yt为时间序列Y的第t个取值，B是滞后算子，θ和φ为模型参数。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">131</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>ARIMA的执行流程主要分为模型识别(Model Identification)、参数估计(Parameter Estimation)和诊断检测(Diagnostic Checking)三个阶段。</span><a href='../sentence_detail/339.htm' target='right' class='orange' >其中，模型识别阶段主要完成检测序列是否平稳的工作。</a><a href='../sentence_detail/340.htm' target='right' class='orange' >如果序列不平稳，那么需要通过差分的方法将序列转化为平稳序列并给出差分阶数d。</a><a href='../sentence_detail/341.htm' target='right' class='orange' >在此基础上，识别出序列适用的可能模型，如自回归模型或滑动平均模型或者二者的混合。</a><a href='../sentence_detail/342.htm' target='right' class='orange' >而参数估计阶段主要完成模型参数的估计工作，即通过最小二乘法估计参数θ和φ。</a><span class='green'>诊断检测阶段用以检测所给出的模型及参数是否符合条件，如果符合则选用此模型进行预测，否则重新识别模型。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">132</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>ARIMA模型已经在计量经济学中得到了非常广泛地应用而且也取得了比较理想的预测效果，</span><span class='green'>因此本文后续的工作中将使用该模型完成对用户行为序列的分析和预测工作。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">133</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/346.htm' target='right' class='orange' >第三章 基于多维时间序列分析的音乐推荐方法</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">134</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本章将给出一种基于多维时间序列分析的音乐推荐方法，该方法实现了对用户听歌行为定量且全面地分析和预测，</span><a href='../sentence_detail/348.htm' target='right' class='orange' >同时减少了对其他用户行为的依赖，使得推荐的结果更加符合用户即时偏好。</a><span class='green'>首先，该方法使用用户给歌曲所打的标签构造歌曲对应的文档，进而通过主题模型的方法对文档集合进行建模并</span><span class='green'>最终把每一首歌曲都表示成由若干隐含主题构成的一个概率分布。</span><span class='green'>在此基础上，该方法将用户在当前会话期内的听歌行为建模为一个多维时间序列，</span><span class='green'>并通过对该多维时间序列的分析来预测用户行为，而这样做的原因是该方法认为用户在当前会话期内所收听的歌曲序列能够在一定程度上表征其所处的上下文环境。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">135</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/353.htm' target='right' class='orange' >我们将在本章中对该方法进行详细地阐述。</a><span class='green'>首先，我们将介绍本文工作所研究问题的相关描述和定义。</span><span class='green'>然后，我们给出该方法的工作流程，包括隐含主题的抽取、多维时间序列的构造及分析预测、最终推荐结果的生成等内容。</span><a href='../sentence_detail/356.htm' target='right' class='orange' >最后，我们介绍为验证该方法有效性而设计的实验及实验结果。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">136</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.1问题描述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">137</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>音乐推荐的目的在于通过对音乐本身属性和用户行为习惯的分析，帮助用户过滤掉不必要的信息，并最终为用户推荐符合其喜好的音乐作品。</span><span class='green'>换句话来说，就是解决如何在已知歌曲特征以及用户之前所收听歌曲的情况下准确地预测用户可能收听的下一首歌曲的问题 [38]，如图3.1所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">138</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图 3.1:</span><span class='green'>下一首歌预测问题的说明图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">139</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了更好地描述本文所要研究的问题，我们首先定义用户集和歌曲集，如下所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">140</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>用户集U：</span><span class='green'>所有用户的集合，如式3.1所示。</span><span class='green'>其中， v表示用户的数目，即v = |U|。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">141</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>歌曲集 S：</span><span class='green'>所有可以推荐给用户的物品 (这里就是歌曲，本文不加区分地使用“歌曲”和“物品” )的集合，如式 3.2所示。</span><a href='../sentence_detail/368.htm' target='right' class='orange' >其中， m表示曲库中歌曲的数目，即m = |S|。</a><span class='green'>为方便起见，我们认为用户收听的歌曲一定在歌曲集合中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">142</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/370.htm' target='right' class='orange' >对于用户集 U中给定的一个用户 u，本文所要研究的音乐推荐系统的目标就是为该用户推荐其可能喜欢的下一首歌曲。</a><span class='green'>为了衡量用户对歌曲的喜欢程度，我们定义如下所示的效用函数：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">143</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>效用函数utility(u， s):</span><span class='green'>表征歌曲 s对用户 u的推荐度 (如歌曲 s符合用户 u喜好的程度、歌曲 s与系统所预测歌曲的相似度等 )。</span><a href='../sentence_detail/374.htm' target='right' class='orange' >效用函数反映了用户对某首歌曲的喜爱程度，其值越大表明喜欢程度越大。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">144</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>如前所述，本文所给的方法是建立在隐含主题分类和用户在当前会话期内听歌序列的基础上，</span><span class='green'>因此我们进一步地定义歌曲对应的隐含主题集合以及用户所收听歌曲对应的序列。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">145</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>主题集 T:</span><a href='../sentence_detail/378.htm' target='right' class='orange' >由所有隐含主题组成的集合，如式式 3.3所示，其中 K为隐含主题的数目。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">146</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>事件 e(u， τ， s):</span><span class='green'>表示用户 u在时刻 τ收听了歌曲 s。</span><span class='green'>显然，歌曲 s可由用户 u和时刻τ唯一决定，因此 e(u， τ， s)可简化为e(u， τ)。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">147</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>序列 Q(u):</span><span class='green'>用户 u在给定平台下的所有听歌事件按照时间顺序排列开来得到的序列，如式 3.4所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">148</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中， π + n为用户 u所收听或喜欢的歌曲数目， τ为事件发生的时间，且τ1 (τ2 (</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">149</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>... ( τ. (τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">150</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>+1 ( ... ( τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">151</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>+n，即用户收听这 π + n首歌曲是按照一定的次序一首接一首收听的。</span><span class='green'>另外， Q(u)中最后 n个事件是用户在当前会话期内产生的，即从事件 e(u， τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">152</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>+1)到事件 e(u， τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">153</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>+n)之间对应的 n首歌曲是用户当前连续收听的，而序列中的最后一个事件 e(u， τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">154</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>+n)是正在发生的。</span><span class='green'>也就是说，这 n个听歌事件两两之间没有明显的时间间隔，而事件 e(u， τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">155</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>+1)和事件 e(u， τ</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">156</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/394.htm' target='right' class='orange' >)之间有明显的时间间隔，如式 3.5和3.6所示。</a>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_11.htm">尾页</a>
页码：4/11页
]
</div>

</div>

<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2013 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
